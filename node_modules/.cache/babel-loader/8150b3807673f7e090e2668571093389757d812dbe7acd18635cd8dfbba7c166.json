{"ast":null,"code":"import { FunctionsClient } from '@supabase/functions-js';\nimport { PostgrestClient } from '@supabase/postgrest-js';\nimport { RealtimeClient } from '@supabase/realtime-js';\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js';\nimport { DEFAULT_AUTH_OPTIONS, DEFAULT_DB_OPTIONS, DEFAULT_GLOBAL_OPTIONS, DEFAULT_REALTIME_OPTIONS } from './lib/constants';\nimport { fetchWithAuth } from './lib/fetch';\nimport { applySettingDefaults, validateSupabaseUrl } from './lib/helpers';\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient';\n/**\r\n * Supabase Client.\r\n *\r\n * An isomorphic Javascript client for interacting with Postgres.\r\n */\nexport default class SupabaseClient {\n  /**\r\n   * Create a new client for use in the browser.\r\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\r\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\r\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\r\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\r\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\r\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\r\n   * @param options.realtime Options passed along to realtime-js constructor.\r\n   * @param options.storage Options passed along to the storage-js constructor.\r\n   * @param options.global.fetch A custom fetch implementation.\r\n   * @param options.global.headers Any additional headers to send with each network request.\r\n   */\n  constructor(supabaseUrl, supabaseKey, options) {\n    var _a, _b, _c;\n    this.supabaseUrl = supabaseUrl;\n    this.supabaseKey = supabaseKey;\n    const baseUrl = validateSupabaseUrl(supabaseUrl);\n    if (!supabaseKey) throw new Error('supabaseKey is required.');\n    this.realtimeUrl = new URL('realtime/v1', baseUrl);\n    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws');\n    this.authUrl = new URL('auth/v1', baseUrl);\n    this.storageUrl = new URL('storage/v1', baseUrl);\n    this.functionsUrl = new URL('functions/v1', baseUrl);\n    // default storage key uses the supabase project ref as a namespace\n    const defaultStorageKey = \"sb-\".concat(baseUrl.hostname.split('.')[0], \"-auth-token\");\n    const DEFAULTS = {\n      db: DEFAULT_DB_OPTIONS,\n      realtime: DEFAULT_REALTIME_OPTIONS,\n      auth: Object.assign(Object.assign({}, DEFAULT_AUTH_OPTIONS), {\n        storageKey: defaultStorageKey\n      }),\n      global: DEFAULT_GLOBAL_OPTIONS\n    };\n    const settings = applySettingDefaults(options !== null && options !== void 0 ? options : {}, DEFAULTS);\n    this.storageKey = (_a = settings.auth.storageKey) !== null && _a !== void 0 ? _a : '';\n    this.headers = (_b = settings.global.headers) !== null && _b !== void 0 ? _b : {};\n    if (!settings.accessToken) {\n      this.auth = this._initSupabaseAuthClient((_c = settings.auth) !== null && _c !== void 0 ? _c : {}, this.headers, settings.global.fetch);\n    } else {\n      this.accessToken = settings.accessToken;\n      this.auth = new Proxy({}, {\n        get: (_, prop) => {\n          throw new Error(\"@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.\".concat(String(prop), \" is not possible\"));\n        }\n      });\n    }\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch);\n    this.realtime = this._initRealtimeClient(Object.assign({\n      headers: this.headers,\n      accessToken: this._getAccessToken.bind(this)\n    }, settings.realtime));\n    this.rest = new PostgrestClient(new URL('rest/v1', baseUrl).href, {\n      headers: this.headers,\n      schema: settings.db.schema,\n      fetch: this.fetch\n    });\n    this.storage = new SupabaseStorageClient(this.storageUrl.href, this.headers, this.fetch, options === null || options === void 0 ? void 0 : options.storage);\n    if (!settings.accessToken) {\n      this._listenForAuthEvents();\n    }\n  }\n  /**\r\n   * Supabase Functions allows you to deploy and invoke edge functions.\r\n   */\n  get functions() {\n    return new FunctionsClient(this.functionsUrl.href, {\n      headers: this.headers,\n      customFetch: this.fetch\n    });\n  }\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\n  from(relation) {\n    return this.rest.from(relation);\n  }\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\n  /**\r\n   * Select a schema to query or perform an function (rpc) call.\r\n   *\r\n   * The schema needs to be on the list of exposed schemas inside Supabase.\r\n   *\r\n   * @param schema - The schema to query\r\n   */\n  schema(schema) {\n    return this.rest.schema(schema);\n  }\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn - The function name to call\r\n   * @param args - The arguments to pass to the function call\r\n   * @param options - Named parameters\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   * @param options.get - When set to `true`, the function will be called with\r\n   * read-only access mode.\r\n   * @param options.count - Count algorithm to use to count rows returned by the\r\n   * function. Only applicable for [set-returning\r\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\n  rpc(fn) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {\n      head: false,\n      get: false,\n      count: undefined\n    };\n    return this.rest.rpc(fn, args, options);\n  }\n  /**\r\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\r\n   *\r\n   * @param {string} name - The name of the Realtime channel.\r\n   * @param {Object} opts - The options to pass to the Realtime channel.\r\n   *\r\n   */\n  channel(name) {\n    let opts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      config: {}\n    };\n    return this.realtime.channel(name, opts);\n  }\n  /**\r\n   * Returns all Realtime channels.\r\n   */\n  getChannels() {\n    return this.realtime.getChannels();\n  }\n  /**\r\n   * Unsubscribes and removes Realtime channel from Realtime client.\r\n   *\r\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\r\n   *\r\n   */\n  removeChannel(channel) {\n    return this.realtime.removeChannel(channel);\n  }\n  /**\r\n   * Unsubscribes and removes all Realtime channels from Realtime client.\r\n   */\n  removeAllChannels() {\n    return this.realtime.removeAllChannels();\n  }\n  async _getAccessToken() {\n    var _a, _b;\n    if (this.accessToken) {\n      return await this.accessToken();\n    }\n    const {\n      data\n    } = await this.auth.getSession();\n    return (_b = (_a = data.session) === null || _a === void 0 ? void 0 : _a.access_token) !== null && _b !== void 0 ? _b : this.supabaseKey;\n  }\n  _initSupabaseAuthClient(_ref, headers, fetch) {\n    let {\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      userStorage,\n      storageKey,\n      flowType,\n      lock,\n      debug\n    } = _ref;\n    const authHeaders = {\n      Authorization: \"Bearer \".concat(this.supabaseKey),\n      apikey: \"\".concat(this.supabaseKey)\n    };\n    return new SupabaseAuthClient({\n      url: this.authUrl.href,\n      headers: Object.assign(Object.assign({}, authHeaders), headers),\n      storageKey: storageKey,\n      autoRefreshToken,\n      persistSession,\n      detectSessionInUrl,\n      storage,\n      userStorage,\n      flowType,\n      lock,\n      debug,\n      fetch,\n      // auth checks if there is a custom authorizaiton header using this flag\n      // so it knows whether to return an error when getUser is called with no session\n      hasCustomAuthorizationHeader: Object.keys(this.headers).some(key => key.toLowerCase() === 'authorization')\n    });\n  }\n  _initRealtimeClient(options) {\n    return new RealtimeClient(this.realtimeUrl.href, Object.assign(Object.assign({}, options), {\n      params: Object.assign({\n        apikey: this.supabaseKey\n      }, options === null || options === void 0 ? void 0 : options.params)\n    }));\n  }\n  _listenForAuthEvents() {\n    const data = this.auth.onAuthStateChange((event, session) => {\n      this._handleTokenChanged(event, 'CLIENT', session === null || session === void 0 ? void 0 : session.access_token);\n    });\n    return data;\n  }\n  _handleTokenChanged(event, source, token) {\n    if ((event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') && this.changedAccessToken !== token) {\n      this.changedAccessToken = token;\n      this.realtime.setAuth(token);\n    } else if (event === 'SIGNED_OUT') {\n      this.realtime.setAuth();\n      if (source == 'STORAGE') this.auth.signOut();\n      this.changedAccessToken = undefined;\n    }\n  }\n}","map":{"version":3,"names":["FunctionsClient","PostgrestClient","RealtimeClient","StorageClient","SupabaseStorageClient","DEFAULT_AUTH_OPTIONS","DEFAULT_DB_OPTIONS","DEFAULT_GLOBAL_OPTIONS","DEFAULT_REALTIME_OPTIONS","fetchWithAuth","applySettingDefaults","validateSupabaseUrl","SupabaseAuthClient","SupabaseClient","constructor","supabaseUrl","supabaseKey","options","baseUrl","Error","realtimeUrl","URL","protocol","replace","authUrl","storageUrl","functionsUrl","defaultStorageKey","concat","hostname","split","DEFAULTS","db","realtime","auth","Object","assign","storageKey","global","settings","_a","headers","_b","accessToken","_initSupabaseAuthClient","_c","fetch","Proxy","get","_","prop","String","_getAccessToken","bind","_initRealtimeClient","rest","href","schema","storage","_listenForAuthEvents","functions","customFetch","from","relation","rpc","fn","args","arguments","length","undefined","head","count","channel","name","opts","config","getChannels","removeChannel","removeAllChannels","data","getSession","session","access_token","_ref","autoRefreshToken","persistSession","detectSessionInUrl","userStorage","flowType","lock","debug","authHeaders","Authorization","apikey","url","hasCustomAuthorizationHeader","keys","some","key","toLowerCase","params","onAuthStateChange","event","_handleTokenChanged","source","token","changedAccessToken","setAuth","signOut"],"sources":["C:\\Users\\bread\\Downloads\\html\\web_ban_sach\\node_modules\\@supabase\\supabase-js\\src\\SupabaseClient.ts"],"sourcesContent":["import type { AuthChangeEvent } from '@supabase/auth-js'\r\nimport { FunctionsClient } from '@supabase/functions-js'\r\nimport {\r\n  PostgrestClient,\r\n  type PostgrestFilterBuilder,\r\n  type PostgrestQueryBuilder,\r\n} from '@supabase/postgrest-js'\r\nimport {\r\n  type RealtimeChannel,\r\n  type RealtimeChannelOptions,\r\n  RealtimeClient,\r\n  type RealtimeClientOptions,\r\n} from '@supabase/realtime-js'\r\nimport { StorageClient as SupabaseStorageClient } from '@supabase/storage-js'\r\nimport {\r\n  DEFAULT_AUTH_OPTIONS,\r\n  DEFAULT_DB_OPTIONS,\r\n  DEFAULT_GLOBAL_OPTIONS,\r\n  DEFAULT_REALTIME_OPTIONS,\r\n} from './lib/constants'\r\nimport { fetchWithAuth } from './lib/fetch'\r\nimport { applySettingDefaults, validateSupabaseUrl } from './lib/helpers'\r\nimport { SupabaseAuthClient } from './lib/SupabaseAuthClient'\r\nimport type {\r\n  Fetch,\r\n  GenericSchema,\r\n  SupabaseAuthClientOptions,\r\n  SupabaseClientOptions,\r\n} from './lib/types'\r\nimport { GetRpcFunctionFilterBuilderByArgs } from './lib/rest/types/common/rpc'\r\n\r\n/**\r\n * Supabase Client.\r\n *\r\n * An isomorphic Javascript client for interacting with Postgres.\r\n */\r\nexport default class SupabaseClient<\r\n  Database = any,\r\n  // The second type parameter is also used for specifying db_schema, so we\r\n  // support both cases.\r\n  // TODO: Allow setting db_schema from ClientOptions.\r\n  SchemaNameOrClientOptions extends\r\n    | (string & keyof Omit<Database, '__InternalSupabase'>)\r\n    | { PostgrestVersion: string } = 'public' extends keyof Omit<Database, '__InternalSupabase'>\r\n    ? 'public'\r\n    : string & keyof Omit<Database, '__InternalSupabase'>,\r\n  SchemaName extends string &\r\n    keyof Omit<Database, '__InternalSupabase'> = SchemaNameOrClientOptions extends string &\r\n    keyof Omit<Database, '__InternalSupabase'>\r\n    ? SchemaNameOrClientOptions\r\n    : 'public' extends keyof Omit<Database, '__InternalSupabase'>\r\n      ? 'public'\r\n      : string & keyof Omit<Omit<Database, '__InternalSupabase'>, '__InternalSupabase'>,\r\n  Schema extends Omit<Database, '__InternalSupabase'>[SchemaName] extends GenericSchema\r\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\r\n    : never = Omit<Database, '__InternalSupabase'>[SchemaName] extends GenericSchema\r\n    ? Omit<Database, '__InternalSupabase'>[SchemaName]\r\n    : never,\r\n  ClientOptions extends { PostgrestVersion: string } = SchemaNameOrClientOptions extends string &\r\n    keyof Omit<Database, '__InternalSupabase'>\r\n    ? // If the version isn't explicitly set, look for it in the __InternalSupabase object to infer the right version\r\n      Database extends { __InternalSupabase: { PostgrestVersion: string } }\r\n      ? Database['__InternalSupabase']\r\n      : // otherwise default to 12\r\n        { PostgrestVersion: '12' }\r\n    : SchemaNameOrClientOptions extends { PostgrestVersion: string }\r\n      ? SchemaNameOrClientOptions\r\n      : never,\r\n> {\r\n  /**\r\n   * Supabase Auth allows you to create and manage user sessions for access to data that is secured by access policies.\r\n   */\r\n  auth: SupabaseAuthClient\r\n  realtime: RealtimeClient\r\n  /**\r\n   * Supabase Storage allows you to manage user-generated content, such as photos or videos.\r\n   */\r\n  storage: SupabaseStorageClient\r\n\r\n  protected realtimeUrl: URL\r\n  protected authUrl: URL\r\n  protected storageUrl: URL\r\n  protected functionsUrl: URL\r\n  protected rest: PostgrestClient<Database, ClientOptions, SchemaName>\r\n  protected storageKey: string\r\n  protected fetch?: Fetch\r\n  protected changedAccessToken?: string\r\n  protected accessToken?: () => Promise<string | null>\r\n\r\n  protected headers: Record<string, string>\r\n\r\n  /**\r\n   * Create a new client for use in the browser.\r\n   * @param supabaseUrl The unique Supabase URL which is supplied when you create a new project in your project dashboard.\r\n   * @param supabaseKey The unique Supabase Key which is supplied when you create a new project in your project dashboard.\r\n   * @param options.db.schema You can switch in between schemas. The schema needs to be on the list of exposed schemas inside Supabase.\r\n   * @param options.auth.autoRefreshToken Set to \"true\" if you want to automatically refresh the token before expiring.\r\n   * @param options.auth.persistSession Set to \"true\" if you want to automatically save the user session into local storage.\r\n   * @param options.auth.detectSessionInUrl Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user.\r\n   * @param options.realtime Options passed along to realtime-js constructor.\r\n   * @param options.storage Options passed along to the storage-js constructor.\r\n   * @param options.global.fetch A custom fetch implementation.\r\n   * @param options.global.headers Any additional headers to send with each network request.\r\n   */\r\n  constructor(\r\n    protected supabaseUrl: string,\r\n    protected supabaseKey: string,\r\n    options?: SupabaseClientOptions<SchemaName>\r\n  ) {\r\n    const baseUrl = validateSupabaseUrl(supabaseUrl)\r\n    if (!supabaseKey) throw new Error('supabaseKey is required.')\r\n\r\n    this.realtimeUrl = new URL('realtime/v1', baseUrl)\r\n    this.realtimeUrl.protocol = this.realtimeUrl.protocol.replace('http', 'ws')\r\n    this.authUrl = new URL('auth/v1', baseUrl)\r\n    this.storageUrl = new URL('storage/v1', baseUrl)\r\n    this.functionsUrl = new URL('functions/v1', baseUrl)\r\n\r\n    // default storage key uses the supabase project ref as a namespace\r\n    const defaultStorageKey = `sb-${baseUrl.hostname.split('.')[0]}-auth-token`\r\n    const DEFAULTS = {\r\n      db: DEFAULT_DB_OPTIONS,\r\n      realtime: DEFAULT_REALTIME_OPTIONS,\r\n      auth: { ...DEFAULT_AUTH_OPTIONS, storageKey: defaultStorageKey },\r\n      global: DEFAULT_GLOBAL_OPTIONS,\r\n    }\r\n\r\n    const settings = applySettingDefaults(options ?? {}, DEFAULTS)\r\n\r\n    this.storageKey = settings.auth.storageKey ?? ''\r\n    this.headers = settings.global.headers ?? {}\r\n\r\n    if (!settings.accessToken) {\r\n      this.auth = this._initSupabaseAuthClient(\r\n        settings.auth ?? {},\r\n        this.headers,\r\n        settings.global.fetch\r\n      )\r\n    } else {\r\n      this.accessToken = settings.accessToken\r\n\r\n      this.auth = new Proxy<SupabaseAuthClient>({} as any, {\r\n        get: (_, prop) => {\r\n          throw new Error(\r\n            `@supabase/supabase-js: Supabase Client is configured with the accessToken option, accessing supabase.auth.${String(\r\n              prop\r\n            )} is not possible`\r\n          )\r\n        },\r\n      })\r\n    }\r\n\r\n    this.fetch = fetchWithAuth(supabaseKey, this._getAccessToken.bind(this), settings.global.fetch)\r\n    this.realtime = this._initRealtimeClient({\r\n      headers: this.headers,\r\n      accessToken: this._getAccessToken.bind(this),\r\n      ...settings.realtime,\r\n    })\r\n    this.rest = new PostgrestClient(new URL('rest/v1', baseUrl).href, {\r\n      headers: this.headers,\r\n      schema: settings.db.schema,\r\n      fetch: this.fetch,\r\n    })\r\n\r\n    this.storage = new SupabaseStorageClient(\r\n      this.storageUrl.href,\r\n      this.headers,\r\n      this.fetch,\r\n      options?.storage\r\n    )\r\n\r\n    if (!settings.accessToken) {\r\n      this._listenForAuthEvents()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Supabase Functions allows you to deploy and invoke edge functions.\r\n   */\r\n  get functions(): FunctionsClient {\r\n    return new FunctionsClient(this.functionsUrl.href, {\r\n      headers: this.headers,\r\n      customFetch: this.fetch,\r\n    })\r\n  }\r\n\r\n  // NOTE: signatures must be kept in sync with PostgrestClient.from\r\n  from<\r\n    TableName extends string & keyof Schema['Tables'],\r\n    Table extends Schema['Tables'][TableName],\r\n  >(relation: TableName): PostgrestQueryBuilder<ClientOptions, Schema, Table, TableName>\r\n  from<ViewName extends string & keyof Schema['Views'], View extends Schema['Views'][ViewName]>(\r\n    relation: ViewName\r\n  ): PostgrestQueryBuilder<ClientOptions, Schema, View, ViewName>\r\n  /**\r\n   * Perform a query on a table or a view.\r\n   *\r\n   * @param relation - The table or view name to query\r\n   */\r\n  from(relation: string): PostgrestQueryBuilder<ClientOptions, Schema, any> {\r\n    return this.rest.from(relation)\r\n  }\r\n\r\n  // NOTE: signatures must be kept in sync with PostgrestClient.schema\r\n  /**\r\n   * Select a schema to query or perform an function (rpc) call.\r\n   *\r\n   * The schema needs to be on the list of exposed schemas inside Supabase.\r\n   *\r\n   * @param schema - The schema to query\r\n   */\r\n  schema<DynamicSchema extends string & keyof Omit<Database, '__InternalSupabase'>>(\r\n    schema: DynamicSchema\r\n  ): PostgrestClient<\r\n    Database,\r\n    ClientOptions,\r\n    DynamicSchema,\r\n    Database[DynamicSchema] extends GenericSchema ? Database[DynamicSchema] : any\r\n  > {\r\n    return this.rest.schema<DynamicSchema>(schema)\r\n  }\r\n\r\n  // NOTE: signatures must be kept in sync with PostgrestClient.rpc\r\n  /**\r\n   * Perform a function call.\r\n   *\r\n   * @param fn - The function name to call\r\n   * @param args - The arguments to pass to the function call\r\n   * @param options - Named parameters\r\n   * @param options.head - When set to `true`, `data` will not be returned.\r\n   * Useful if you only need the count.\r\n   * @param options.get - When set to `true`, the function will be called with\r\n   * read-only access mode.\r\n   * @param options.count - Count algorithm to use to count rows returned by the\r\n   * function. Only applicable for [set-returning\r\n   * functions](https://www.postgresql.org/docs/current/functions-srf.html).\r\n   *\r\n   * `\"exact\"`: Exact but slow count algorithm. Performs a `COUNT(*)` under the\r\n   * hood.\r\n   *\r\n   * `\"planned\"`: Approximated but fast count algorithm. Uses the Postgres\r\n   * statistics under the hood.\r\n   *\r\n   * `\"estimated\"`: Uses exact count for low numbers and planned count for high\r\n   * numbers.\r\n   */\r\n  rpc<\r\n    FnName extends string & keyof Schema['Functions'],\r\n    Args extends Schema['Functions'][FnName]['Args'] = never,\r\n    FilterBuilder extends GetRpcFunctionFilterBuilderByArgs<\r\n      Schema,\r\n      FnName,\r\n      Args\r\n    > = GetRpcFunctionFilterBuilderByArgs<Schema, FnName, Args>,\r\n  >(\r\n    fn: FnName,\r\n    args: Args = {} as Args,\r\n    options: {\r\n      head?: boolean\r\n      get?: boolean\r\n      count?: 'exact' | 'planned' | 'estimated'\r\n    } = {\r\n      head: false,\r\n      get: false,\r\n      count: undefined,\r\n    }\r\n  ): PostgrestFilterBuilder<\r\n    ClientOptions,\r\n    Schema,\r\n    FilterBuilder['Row'],\r\n    FilterBuilder['Result'],\r\n    FilterBuilder['RelationName'],\r\n    FilterBuilder['Relationships'],\r\n    'RPC'\r\n  > {\r\n    return this.rest.rpc(fn, args, options) as unknown as PostgrestFilterBuilder<\r\n      ClientOptions,\r\n      Schema,\r\n      FilterBuilder['Row'],\r\n      FilterBuilder['Result'],\r\n      FilterBuilder['RelationName'],\r\n      FilterBuilder['Relationships'],\r\n      'RPC'\r\n    >\r\n  }\r\n\r\n  /**\r\n   * Creates a Realtime channel with Broadcast, Presence, and Postgres Changes.\r\n   *\r\n   * @param {string} name - The name of the Realtime channel.\r\n   * @param {Object} opts - The options to pass to the Realtime channel.\r\n   *\r\n   */\r\n  channel(name: string, opts: RealtimeChannelOptions = { config: {} }): RealtimeChannel {\r\n    return this.realtime.channel(name, opts)\r\n  }\r\n\r\n  /**\r\n   * Returns all Realtime channels.\r\n   */\r\n  getChannels(): RealtimeChannel[] {\r\n    return this.realtime.getChannels()\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes Realtime channel from Realtime client.\r\n   *\r\n   * @param {RealtimeChannel} channel - The name of the Realtime channel.\r\n   *\r\n   */\r\n  removeChannel(channel: RealtimeChannel): Promise<'ok' | 'timed out' | 'error'> {\r\n    return this.realtime.removeChannel(channel)\r\n  }\r\n\r\n  /**\r\n   * Unsubscribes and removes all Realtime channels from Realtime client.\r\n   */\r\n  removeAllChannels(): Promise<('ok' | 'timed out' | 'error')[]> {\r\n    return this.realtime.removeAllChannels()\r\n  }\r\n\r\n  private async _getAccessToken() {\r\n    if (this.accessToken) {\r\n      return await this.accessToken()\r\n    }\r\n\r\n    const { data } = await this.auth.getSession()\r\n\r\n    return data.session?.access_token ?? this.supabaseKey\r\n  }\r\n\r\n  private _initSupabaseAuthClient(\r\n    {\r\n      autoRefreshToken,\r\n      persistSession,\r\n      detectSessionInUrl,\r\n      storage,\r\n      userStorage,\r\n      storageKey,\r\n      flowType,\r\n      lock,\r\n      debug,\r\n    }: SupabaseAuthClientOptions,\r\n    headers?: Record<string, string>,\r\n    fetch?: Fetch\r\n  ) {\r\n    const authHeaders = {\r\n      Authorization: `Bearer ${this.supabaseKey}`,\r\n      apikey: `${this.supabaseKey}`,\r\n    }\r\n    return new SupabaseAuthClient({\r\n      url: this.authUrl.href,\r\n      headers: { ...authHeaders, ...headers },\r\n      storageKey: storageKey,\r\n      autoRefreshToken,\r\n      persistSession,\r\n      detectSessionInUrl,\r\n      storage,\r\n      userStorage,\r\n      flowType,\r\n      lock,\r\n      debug,\r\n      fetch,\r\n      // auth checks if there is a custom authorizaiton header using this flag\r\n      // so it knows whether to return an error when getUser is called with no session\r\n      hasCustomAuthorizationHeader: Object.keys(this.headers).some(\r\n        (key) => key.toLowerCase() === 'authorization'\r\n      ),\r\n    })\r\n  }\r\n\r\n  private _initRealtimeClient(options: RealtimeClientOptions) {\r\n    return new RealtimeClient(this.realtimeUrl.href, {\r\n      ...options,\r\n      params: { ...{ apikey: this.supabaseKey }, ...options?.params },\r\n    })\r\n  }\r\n\r\n  private _listenForAuthEvents() {\r\n    const data = this.auth.onAuthStateChange((event, session) => {\r\n      this._handleTokenChanged(event, 'CLIENT', session?.access_token)\r\n    })\r\n    return data\r\n  }\r\n\r\n  private _handleTokenChanged(\r\n    event: AuthChangeEvent,\r\n    source: 'CLIENT' | 'STORAGE',\r\n    token?: string\r\n  ) {\r\n    if (\r\n      (event === 'TOKEN_REFRESHED' || event === 'SIGNED_IN') &&\r\n      this.changedAccessToken !== token\r\n    ) {\r\n      this.changedAccessToken = token\r\n      this.realtime.setAuth(token)\r\n    } else if (event === 'SIGNED_OUT') {\r\n      this.realtime.setAuth()\r\n      if (source == 'STORAGE') this.auth.signOut()\r\n      this.changedAccessToken = undefined\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}