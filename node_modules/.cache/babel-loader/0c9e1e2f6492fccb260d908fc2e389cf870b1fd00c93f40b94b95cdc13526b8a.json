{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { DEFAULT_HEADERS } from './constants';\nimport { isStorageVectorsError } from './errors';\nimport { post } from './fetch';\nimport { resolveFetch } from './helpers';\n/**\r\n * API class for managing Vector Data within Vector Indexes\r\n * Provides methods for inserting, querying, listing, and deleting vector embeddings\r\n */\nexport default class VectorDataApi {\n  constructor(url) {\n    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fetch = arguments.length > 2 ? arguments[2] : undefined;\n    this.shouldThrowOnError = false;\n    this.url = url.replace(/\\/$/, '');\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\r\n   * Enable throwing errors instead of returning them in the response\r\n   * When enabled, failed operations will throw instead of returning { data: null, error }\r\n   *\r\n   * @returns This instance for method chaining\r\n   * @example\r\n   * ```typescript\r\n   * const client = new VectorDataApi(url, headers)\r\n   * client.throwOnError()\r\n   * const { data } = await client.putVectors(options) // throws on error\r\n   * ```\r\n   */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /**\r\n   * Inserts or updates vectors in batch (upsert operation)\r\n   * Accepts 1-500 vectors per request. Larger batches should be split\r\n   *\r\n   * @param options - Vector insertion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the target index\r\n   * @param options.vectors - Array of vectors to insert/update (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.putVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   vectors: [\r\n   *     {\r\n   *       key: 'doc-1',\r\n   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *       metadata: { title: 'Introduction', page: 1 }\r\n   *     },\r\n   *     {\r\n   *       key: 'doc-2',\r\n   *       data: { float32: [0.4, 0.5, 0.6, ...] },\r\n   *       metadata: { title: 'Conclusion', page: 42 }\r\n   *     }\r\n   *   ]\r\n   * })\r\n   * ```\r\n   */\n  putVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.vectors.length < 1 || options.vectors.length > 500) {\n          throw new Error('Vector batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/PutVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Retrieves vectors by their keys in batch\r\n   * Optionally includes vector data and/or metadata in response\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector retrieval options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to retrieve\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @returns Promise with array of vectors or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.getVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3'],\r\n   *   returnData: false,     // Don't return embeddings\r\n   *   returnMetadata: true   // Return metadata only\r\n   * })\r\n   * if (data) {\r\n   *   data.vectors.forEach(v => console.log(v.key, v.metadata))\r\n   * }\r\n   * ```\r\n   */\n  getVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/GetVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Lists/scans vectors in an index with pagination\r\n   * Supports parallel scanning via segment configuration for high-throughput scenarios\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector listing options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)\r\n   * @param options.nextToken - Pagination token from previous response\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning\r\n   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)\r\n   * @returns Promise with array of vectors, pagination token, or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Simple pagination\r\n   * let nextToken: string | undefined\r\n   * do {\r\n   *   const { data, error } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     maxResults: 500,\r\n   *     nextToken,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   if (error) break\r\n   *   console.log('Batch:', data.vectors.length)\r\n   *   nextToken = data.nextToken\r\n   * } while (nextToken)\r\n   *\r\n   * // Parallel scanning (4 concurrent workers)\r\n   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {\r\n   *   const { data } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     segmentCount: 4,\r\n   *     segmentIndex,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   return data?.vectors || []\r\n   * })\r\n   * const results = await Promise.all(workers)\r\n   * ```\r\n   */\n  listVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate segment configuration\n        if (options.segmentCount !== undefined) {\n          if (options.segmentCount < 1 || options.segmentCount > 16) {\n            throw new Error('segmentCount must be between 1 and 16');\n          }\n          if (options.segmentIndex !== undefined) {\n            if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\n              throw new Error(\"segmentIndex must be between 0 and \".concat(options.segmentCount - 1));\n            }\n          }\n        }\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/ListVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Queries for similar vectors using approximate nearest neighbor (ANN) search\r\n   * Returns top-K most similar vectors based on the configured distance metric\r\n   * Supports optional metadata filtering (requires GetVectors permission)\r\n   *\r\n   * @param options - Query options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.queryVector - Query embedding to find similar vectors\r\n   * @param options.topK - Number of nearest neighbors to return (default: 10)\r\n   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)\r\n   * @param options.returnDistance - Whether to include similarity distances\r\n   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)\r\n   * @returns Promise with array of similar vectors ordered by distance\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Semantic search with filtering\r\n   * const { data, error } = await client.queryVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *   topK: 5,\r\n   *   filter: {\r\n   *     category: 'technical',\r\n   *     published: true\r\n   *   },\r\n   *   returnDistance: true,\r\n   *   returnMetadata: true\r\n   * })\r\n   * if (data) {\r\n   *   data.matches.forEach(match => {\r\n   *     console.log(`${match.key}: distance=${match.distance}`)\r\n   *     console.log('Metadata:', match.metadata)\r\n   *   })\r\n   * }\r\n   * ```\r\n   */\n  queryVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/QueryVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Deletes vectors by their keys in batch\r\n   * Accepts 1-500 keys per request\r\n   *\r\n   * @param options - Vector deletion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to delete (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { error } = await client.deleteVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3']\r\n   * })\r\n   * if (!error) {\r\n   *   console.log('Vectors deleted successfully')\r\n   * }\r\n   * ```\r\n   */\n  deleteVectors(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        // Validate batch size\n        if (options.keys.length < 1 || options.keys.length > 500) {\n          throw new Error('Keys batch size must be between 1 and 500 items');\n        }\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/DeleteVectors\"), options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}","map":{"version":3,"names":["DEFAULT_HEADERS","isStorageVectorsError","post","resolveFetch","VectorDataApi","constructor","url","headers","arguments","length","undefined","fetch","shouldThrowOnError","replace","Object","assign","throwOnError","putVectors","options","vectors","Error","data","concat","error","getVectors","listVectors","segmentCount","segmentIndex","queryVectors","deleteVectors","keys"],"sources":["C:\\Users\\bread\\Downloads\\html\\web_ban_sach\\node_modules\\@supabase\\storage-js\\src\\lib\\vectors\\VectorDataApi.ts"],"sourcesContent":["import { DEFAULT_HEADERS } from './constants'\r\nimport { isStorageVectorsError } from './errors'\r\nimport { Fetch, post } from './fetch'\r\nimport { resolveFetch } from './helpers'\r\nimport {\r\n  ApiResponse,\r\n  PutVectorsOptions,\r\n  GetVectorsOptions,\r\n  GetVectorsResponse,\r\n  DeleteVectorsOptions,\r\n  ListVectorsOptions,\r\n  ListVectorsResponse,\r\n  QueryVectorsOptions,\r\n  QueryVectorsResponse,\r\n} from './types'\r\n\r\n/**\r\n * API class for managing Vector Data within Vector Indexes\r\n * Provides methods for inserting, querying, listing, and deleting vector embeddings\r\n */\r\nexport default class VectorDataApi {\r\n  protected url: string\r\n  protected headers: { [key: string]: string }\r\n  protected fetch: Fetch\r\n  protected shouldThrowOnError = false\r\n\r\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\r\n    this.url = url.replace(/\\/$/, '')\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.fetch = resolveFetch(fetch)\r\n  }\r\n\r\n  /**\r\n   * Enable throwing errors instead of returning them in the response\r\n   * When enabled, failed operations will throw instead of returning { data: null, error }\r\n   *\r\n   * @returns This instance for method chaining\r\n   * @example\r\n   * ```typescript\r\n   * const client = new VectorDataApi(url, headers)\r\n   * client.throwOnError()\r\n   * const { data } = await client.putVectors(options) // throws on error\r\n   * ```\r\n   */\r\n  public throwOnError(): this {\r\n    this.shouldThrowOnError = true\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Inserts or updates vectors in batch (upsert operation)\r\n   * Accepts 1-500 vectors per request. Larger batches should be split\r\n   *\r\n   * @param options - Vector insertion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the target index\r\n   * @param options.vectors - Array of vectors to insert/update (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorConflictException` if duplicate key conflict occurs (HTTP 409)\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.putVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   vectors: [\r\n   *     {\r\n   *       key: 'doc-1',\r\n   *       data: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *       metadata: { title: 'Introduction', page: 1 }\r\n   *     },\r\n   *     {\r\n   *       key: 'doc-2',\r\n   *       data: { float32: [0.4, 0.5, 0.6, ...] },\r\n   *       metadata: { title: 'Conclusion', page: 42 }\r\n   *     }\r\n   *   ]\r\n   * })\r\n   * ```\r\n   */\r\n  async putVectors(options: PutVectorsOptions): Promise<ApiResponse<undefined>> {\r\n    try {\r\n      // Validate batch size\r\n      if (options.vectors.length < 1 || options.vectors.length > 500) {\r\n        throw new Error('Vector batch size must be between 1 and 500 items')\r\n      }\r\n\r\n      const data = await post(this.fetch, `${this.url}/PutVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data: data || {}, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves vectors by their keys in batch\r\n   * Optionally includes vector data and/or metadata in response\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector retrieval options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to retrieve\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @returns Promise with array of vectors or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.getVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3'],\r\n   *   returnData: false,     // Don't return embeddings\r\n   *   returnMetadata: true   // Return metadata only\r\n   * })\r\n   * if (data) {\r\n   *   data.vectors.forEach(v => console.log(v.key, v.metadata))\r\n   * }\r\n   * ```\r\n   */\r\n  async getVectors(options: GetVectorsOptions): Promise<ApiResponse<GetVectorsResponse>> {\r\n    try {\r\n      const data = await post(this.fetch, `${this.url}/GetVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Lists/scans vectors in an index with pagination\r\n   * Supports parallel scanning via segment configuration for high-throughput scenarios\r\n   * Additional permissions required when returning data or metadata\r\n   *\r\n   * @param options - Vector listing options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.maxResults - Maximum results per page (default: 500, max: 1000)\r\n   * @param options.nextToken - Pagination token from previous response\r\n   * @param options.returnData - Whether to include vector embeddings (requires permission)\r\n   * @param options.returnMetadata - Whether to include metadata (requires permission)\r\n   * @param options.segmentCount - Total parallel segments (1-16) for distributed scanning\r\n   * @param options.segmentIndex - Zero-based segment index (0 to segmentCount-1)\r\n   * @returns Promise with array of vectors, pagination token, or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Simple pagination\r\n   * let nextToken: string | undefined\r\n   * do {\r\n   *   const { data, error } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     maxResults: 500,\r\n   *     nextToken,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   if (error) break\r\n   *   console.log('Batch:', data.vectors.length)\r\n   *   nextToken = data.nextToken\r\n   * } while (nextToken)\r\n   *\r\n   * // Parallel scanning (4 concurrent workers)\r\n   * const workers = [0, 1, 2, 3].map(async (segmentIndex) => {\r\n   *   const { data } = await client.listVectors({\r\n   *     vectorBucketName: 'embeddings-prod',\r\n   *     indexName: 'documents-openai-small',\r\n   *     segmentCount: 4,\r\n   *     segmentIndex,\r\n   *     returnMetadata: true\r\n   *   })\r\n   *   return data?.vectors || []\r\n   * })\r\n   * const results = await Promise.all(workers)\r\n   * ```\r\n   */\r\n  async listVectors(options: ListVectorsOptions): Promise<ApiResponse<ListVectorsResponse>> {\r\n    try {\r\n      // Validate segment configuration\r\n      if (options.segmentCount !== undefined) {\r\n        if (options.segmentCount < 1 || options.segmentCount > 16) {\r\n          throw new Error('segmentCount must be between 1 and 16')\r\n        }\r\n        if (options.segmentIndex !== undefined) {\r\n          if (options.segmentIndex < 0 || options.segmentIndex >= options.segmentCount) {\r\n            throw new Error(`segmentIndex must be between 0 and ${options.segmentCount - 1}`)\r\n          }\r\n        }\r\n      }\r\n\r\n      const data = await post(this.fetch, `${this.url}/ListVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Queries for similar vectors using approximate nearest neighbor (ANN) search\r\n   * Returns top-K most similar vectors based on the configured distance metric\r\n   * Supports optional metadata filtering (requires GetVectors permission)\r\n   *\r\n   * @param options - Query options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.queryVector - Query embedding to find similar vectors\r\n   * @param options.topK - Number of nearest neighbors to return (default: 10)\r\n   * @param options.filter - Optional JSON filter for metadata (requires GetVectors permission)\r\n   * @param options.returnDistance - Whether to include similarity distances\r\n   * @param options.returnMetadata - Whether to include metadata (requires GetVectors permission)\r\n   * @returns Promise with array of similar vectors ordered by distance\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Semantic search with filtering\r\n   * const { data, error } = await client.queryVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   queryVector: { float32: [0.1, 0.2, 0.3, ...] }, // 1536 dimensions\r\n   *   topK: 5,\r\n   *   filter: {\r\n   *     category: 'technical',\r\n   *     published: true\r\n   *   },\r\n   *   returnDistance: true,\r\n   *   returnMetadata: true\r\n   * })\r\n   * if (data) {\r\n   *   data.matches.forEach(match => {\r\n   *     console.log(`${match.key}: distance=${match.distance}`)\r\n   *     console.log('Metadata:', match.metadata)\r\n   *   })\r\n   * }\r\n   * ```\r\n   */\r\n  async queryVectors(options: QueryVectorsOptions): Promise<ApiResponse<QueryVectorsResponse>> {\r\n    try {\r\n      const data = await post(this.fetch, `${this.url}/QueryVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes vectors by their keys in batch\r\n   * Accepts 1-500 keys per request\r\n   *\r\n   * @param options - Vector deletion options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Name of the index\r\n   * @param options.keys - Array of vector keys to delete (1-500 items)\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket or index doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { error } = await client.deleteVectors({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   keys: ['doc-1', 'doc-2', 'doc-3']\r\n   * })\r\n   * if (!error) {\r\n   *   console.log('Vectors deleted successfully')\r\n   * }\r\n   * ```\r\n   */\r\n  async deleteVectors(options: DeleteVectorsOptions): Promise<ApiResponse<undefined>> {\r\n    try {\r\n      // Validate batch size\r\n      if (options.keys.length < 1 || options.keys.length > 500) {\r\n        throw new Error('Keys batch size must be between 1 and 500 items')\r\n      }\r\n\r\n      const data = await post(this.fetch, `${this.url}/DeleteVectors`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data: data || {}, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}