{"ast":null,"code":"import { __awaiter } from \"tslib\";\nimport { DEFAULT_HEADERS } from './constants';\nimport { isStorageVectorsError } from './errors';\nimport { post } from './fetch';\nimport { resolveFetch } from './helpers';\n/**\r\n * API class for managing Vector Indexes within Vector Buckets\r\n * Provides methods for creating, reading, listing, and deleting vector indexes\r\n */\nexport default class VectorIndexApi {\n  constructor(url) {\n    let headers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fetch = arguments.length > 2 ? arguments[2] : undefined;\n    this.shouldThrowOnError = false;\n    this.url = url.replace(/\\/$/, '');\n    this.headers = Object.assign(Object.assign({}, DEFAULT_HEADERS), headers);\n    this.fetch = resolveFetch(fetch);\n  }\n  /**\r\n   * Enable throwing errors instead of returning them in the response\r\n   * When enabled, failed operations will throw instead of returning { data: null, error }\r\n   *\r\n   * @returns This instance for method chaining\r\n   * @example\r\n   * ```typescript\r\n   * const client = new VectorIndexApi(url, headers)\r\n   * client.throwOnError()\r\n   * const { data } = await client.createIndex(options) // throws on error\r\n   * ```\r\n   */\n  throwOnError() {\n    this.shouldThrowOnError = true;\n    return this;\n  }\n  /**\r\n   * Creates a new vector index within a bucket\r\n   * Defines the schema for vectors including dimensionality, distance metric, and metadata config\r\n   *\r\n   * @param options - Index configuration\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Unique name for the index within the bucket\r\n   * @param options.dataType - Data type for vector components (currently only 'float32')\r\n   * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)\r\n   * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')\r\n   * @param options.metadataConfiguration - Optional config for non-filterable metadata keys\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorConflictException` if index already exists (HTTP 409)\r\n   * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)\r\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.createIndex({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   dataType: 'float32',\r\n   *   dimension: 1536,\r\n   *   distanceMetric: 'cosine',\r\n   *   metadataConfiguration: {\r\n   *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']\r\n   *   }\r\n   * })\r\n   * ```\r\n   */\n  createIndex(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/CreateIndex\"), options, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Retrieves metadata for a specific vector index\r\n   * Returns index configuration including dimension, distance metric, and metadata settings\r\n   *\r\n   * @param vectorBucketName - Name of the parent vector bucket\r\n   * @param indexName - Name of the index to retrieve\r\n   * @returns Promise with index metadata or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')\r\n   * if (data) {\r\n   *   console.log('Index dimension:', data.index.dimension)\r\n   *   console.log('Distance metric:', data.index.distanceMetric)\r\n   * }\r\n   * ```\r\n   */\n  getIndex(vectorBucketName, indexName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/GetIndex\"), {\n          vectorBucketName,\n          indexName\n        }, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Lists vector indexes within a bucket with optional filtering and pagination\r\n   * Supports prefix-based filtering and paginated results\r\n   *\r\n   * @param options - Listing options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.prefix - Filter indexes by name prefix\r\n   * @param options.maxResults - Maximum results per page (default: 100)\r\n   * @param options.nextToken - Pagination token from previous response\r\n   * @returns Promise with list of indexes and pagination token\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // List all indexes in a bucket\r\n   * const { data, error } = await client.listIndexes({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   prefix: 'documents-'\r\n   * })\r\n   * if (data) {\r\n   *   console.log('Found indexes:', data.indexes.map(i => i.indexName))\r\n   *   // Fetch next page if available\r\n   *   if (data.nextToken) {\r\n   *     const next = await client.listIndexes({\r\n   *       vectorBucketName: 'embeddings-prod',\r\n   *       nextToken: data.nextToken\r\n   *     })\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\n  listIndexes(options) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/ListIndexes\"), options, {\n          headers: this.headers\n        });\n        return {\n          data,\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n  /**\r\n   * Deletes a vector index and all its data\r\n   * This operation removes the index schema and all vectors stored in the index\r\n   *\r\n   * @param vectorBucketName - Name of the parent vector bucket\r\n   * @param indexName - Name of the index to delete\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Delete an index and all its vectors\r\n   * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')\r\n   * if (!error) {\r\n   *   console.log('Index deleted successfully')\r\n   * }\r\n   * ```\r\n   */\n  deleteIndex(vectorBucketName, indexName) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield post(this.fetch, \"\".concat(this.url, \"/DeleteIndex\"), {\n          vectorBucketName,\n          indexName\n        }, {\n          headers: this.headers\n        });\n        return {\n          data: data || {},\n          error: null\n        };\n      } catch (error) {\n        if (this.shouldThrowOnError) {\n          throw error;\n        }\n        if (isStorageVectorsError(error)) {\n          return {\n            data: null,\n            error\n          };\n        }\n        throw error;\n      }\n    });\n  }\n}","map":{"version":3,"names":["DEFAULT_HEADERS","isStorageVectorsError","post","resolveFetch","VectorIndexApi","constructor","url","headers","arguments","length","undefined","fetch","shouldThrowOnError","replace","Object","assign","throwOnError","createIndex","options","data","concat","error","getIndex","vectorBucketName","indexName","listIndexes","deleteIndex"],"sources":["C:\\Users\\bread\\Downloads\\html\\web_ban_sach\\node_modules\\@supabase\\storage-js\\src\\lib\\vectors\\VectorIndexApi.ts"],"sourcesContent":["import { DEFAULT_HEADERS } from './constants'\r\nimport { isStorageVectorsError } from './errors'\r\nimport { Fetch, post } from './fetch'\r\nimport { resolveFetch } from './helpers'\r\nimport {\r\n  ApiResponse,\r\n  VectorIndex,\r\n  ListIndexesOptions,\r\n  ListIndexesResponse,\r\n  VectorDataType,\r\n  DistanceMetric,\r\n  MetadataConfiguration,\r\n} from './types'\r\n\r\n/**\r\n * Options for creating a vector index\r\n */\r\nexport interface CreateIndexOptions {\r\n  vectorBucketName: string\r\n  indexName: string\r\n  dataType: VectorDataType\r\n  dimension: number\r\n  distanceMetric: DistanceMetric\r\n  metadataConfiguration?: MetadataConfiguration\r\n}\r\n\r\n/**\r\n * API class for managing Vector Indexes within Vector Buckets\r\n * Provides methods for creating, reading, listing, and deleting vector indexes\r\n */\r\nexport default class VectorIndexApi {\r\n  protected url: string\r\n  protected headers: { [key: string]: string }\r\n  protected fetch: Fetch\r\n  protected shouldThrowOnError = false\r\n\r\n  constructor(url: string, headers: { [key: string]: string } = {}, fetch?: Fetch) {\r\n    this.url = url.replace(/\\/$/, '')\r\n    this.headers = { ...DEFAULT_HEADERS, ...headers }\r\n    this.fetch = resolveFetch(fetch)\r\n  }\r\n\r\n  /**\r\n   * Enable throwing errors instead of returning them in the response\r\n   * When enabled, failed operations will throw instead of returning { data: null, error }\r\n   *\r\n   * @returns This instance for method chaining\r\n   * @example\r\n   * ```typescript\r\n   * const client = new VectorIndexApi(url, headers)\r\n   * client.throwOnError()\r\n   * const { data } = await client.createIndex(options) // throws on error\r\n   * ```\r\n   */\r\n  public throwOnError(): this {\r\n    this.shouldThrowOnError = true\r\n    return this\r\n  }\r\n\r\n  /**\r\n   * Creates a new vector index within a bucket\r\n   * Defines the schema for vectors including dimensionality, distance metric, and metadata config\r\n   *\r\n   * @param options - Index configuration\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.indexName - Unique name for the index within the bucket\r\n   * @param options.dataType - Data type for vector components (currently only 'float32')\r\n   * @param options.dimension - Dimensionality of vectors (e.g., 384, 768, 1536)\r\n   * @param options.distanceMetric - Similarity metric ('cosine', 'euclidean', 'dotproduct')\r\n   * @param options.metadataConfiguration - Optional config for non-filterable metadata keys\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorConflictException` if index already exists (HTTP 409)\r\n   * - `S3VectorMaxIndexesExceeded` if quota exceeded (HTTP 400)\r\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.createIndex({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   indexName: 'documents-openai-small',\r\n   *   dataType: 'float32',\r\n   *   dimension: 1536,\r\n   *   distanceMetric: 'cosine',\r\n   *   metadataConfiguration: {\r\n   *     nonFilterableMetadataKeys: ['raw_text', 'internal_id']\r\n   *   }\r\n   * })\r\n   * ```\r\n   */\r\n  async createIndex(options: CreateIndexOptions): Promise<ApiResponse<undefined>> {\r\n    try {\r\n      const data = await post(this.fetch, `${this.url}/CreateIndex`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data: data || {}, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Retrieves metadata for a specific vector index\r\n   * Returns index configuration including dimension, distance metric, and metadata settings\r\n   *\r\n   * @param vectorBucketName - Name of the parent vector bucket\r\n   * @param indexName - Name of the index to retrieve\r\n   * @returns Promise with index metadata or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * const { data, error } = await client.getIndex('embeddings-prod', 'documents-openai-small')\r\n   * if (data) {\r\n   *   console.log('Index dimension:', data.index.dimension)\r\n   *   console.log('Distance metric:', data.index.distanceMetric)\r\n   * }\r\n   * ```\r\n   */\r\n  async getIndex(\r\n    vectorBucketName: string,\r\n    indexName: string\r\n  ): Promise<ApiResponse<{ index: VectorIndex }>> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/GetIndex`,\r\n        { vectorBucketName, indexName },\r\n        { headers: this.headers }\r\n      )\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Lists vector indexes within a bucket with optional filtering and pagination\r\n   * Supports prefix-based filtering and paginated results\r\n   *\r\n   * @param options - Listing options\r\n   * @param options.vectorBucketName - Name of the parent vector bucket\r\n   * @param options.prefix - Filter indexes by name prefix\r\n   * @param options.maxResults - Maximum results per page (default: 100)\r\n   * @param options.nextToken - Pagination token from previous response\r\n   * @returns Promise with list of indexes and pagination token\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // List all indexes in a bucket\r\n   * const { data, error } = await client.listIndexes({\r\n   *   vectorBucketName: 'embeddings-prod',\r\n   *   prefix: 'documents-'\r\n   * })\r\n   * if (data) {\r\n   *   console.log('Found indexes:', data.indexes.map(i => i.indexName))\r\n   *   // Fetch next page if available\r\n   *   if (data.nextToken) {\r\n   *     const next = await client.listIndexes({\r\n   *       vectorBucketName: 'embeddings-prod',\r\n   *       nextToken: data.nextToken\r\n   *     })\r\n   *   }\r\n   * }\r\n   * ```\r\n   */\r\n  async listIndexes(options: ListIndexesOptions): Promise<ApiResponse<ListIndexesResponse>> {\r\n    try {\r\n      const data = await post(this.fetch, `${this.url}/ListIndexes`, options, {\r\n        headers: this.headers,\r\n      })\r\n      return { data, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Deletes a vector index and all its data\r\n   * This operation removes the index schema and all vectors stored in the index\r\n   *\r\n   * @param vectorBucketName - Name of the parent vector bucket\r\n   * @param indexName - Name of the index to delete\r\n   * @returns Promise with empty response on success or error\r\n   *\r\n   * @throws {StorageVectorsApiError} With code:\r\n   * - `S3VectorNotFoundException` if index or bucket doesn't exist (HTTP 404)\r\n   * - `InternalError` for server errors (HTTP 500)\r\n   *\r\n   * @example\r\n   * ```typescript\r\n   * // Delete an index and all its vectors\r\n   * const { error } = await client.deleteIndex('embeddings-prod', 'old-index')\r\n   * if (!error) {\r\n   *   console.log('Index deleted successfully')\r\n   * }\r\n   * ```\r\n   */\r\n  async deleteIndex(vectorBucketName: string, indexName: string): Promise<ApiResponse<undefined>> {\r\n    try {\r\n      const data = await post(\r\n        this.fetch,\r\n        `${this.url}/DeleteIndex`,\r\n        { vectorBucketName, indexName },\r\n        { headers: this.headers }\r\n      )\r\n      return { data: data || {}, error: null }\r\n    } catch (error) {\r\n      if (this.shouldThrowOnError) {\r\n        throw error\r\n      }\r\n      if (isStorageVectorsError(error)) {\r\n        return { data: null, error }\r\n      }\r\n      throw error\r\n    }\r\n  }\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}