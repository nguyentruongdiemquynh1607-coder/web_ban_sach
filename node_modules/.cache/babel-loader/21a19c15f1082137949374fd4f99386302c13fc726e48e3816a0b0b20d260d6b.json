{"ast":null,"code":"/**\r\n * Avoid modifying this file. It's part of\r\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\r\n * that repo!\r\n */\n/**\r\n * An array of characters that encode 6 bits into a Base64-URL alphabet\r\n * character.\r\n */\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('');\n/**\r\n * An array of characters that can appear in a Base64-URL encoded string but\r\n * should be ignored.\r\n */\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('');\n/**\r\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\r\n * used to skip the character, or if -1 used to error out.\r\n */\nconst FROM_BASE64URL = (() => {\n  const charMap = new Array(128);\n  for (let i = 0; i < charMap.length; i += 1) {\n    charMap[i] = -1;\n  }\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2;\n  }\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i;\n  }\n  return charMap;\n})();\n/**\r\n * Converts a byte to a Base64-URL string.\r\n *\r\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\r\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next Base64 character when ready.\r\n */\nexport function byteToBase64URL(byte, state, emit) {\n  if (byte !== null) {\n    state.queue = state.queue << 8 | byte;\n    state.queuedBits += 8;\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  } else if (state.queuedBits > 0) {\n    state.queue = state.queue << 6 - state.queuedBits;\n    state.queuedBits = 6;\n    while (state.queuedBits >= 6) {\n      const pos = state.queue >> state.queuedBits - 6 & 63;\n      emit(TO_BASE64URL[pos]);\n      state.queuedBits -= 6;\n    }\n  }\n}\n/**\r\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\r\n *\r\n * @param charCode The char code of the JavaScript string.\r\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next byte.\r\n */\nexport function byteFromBase64URL(charCode, state, emit) {\n  const bits = FROM_BASE64URL[charCode];\n  if (bits > -1) {\n    // valid Base64-URL character\n    state.queue = state.queue << 6 | bits;\n    state.queuedBits += 6;\n    while (state.queuedBits >= 8) {\n      emit(state.queue >> state.queuedBits - 8 & 0xff);\n      state.queuedBits -= 8;\n    }\n  } else if (bits === -2) {\n    // ignore spaces, tabs, newlines, =\n    return;\n  } else {\n    throw new Error(\"Invalid Base64-URL character \\\"\".concat(String.fromCharCode(charCode), \"\\\"\"));\n  }\n}\n/**\r\n * Converts a JavaScript string (which may include any valid character) into a\r\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\r\n * then encoded as Base64-URL.\r\n *\r\n * @param str The string to convert.\r\n */\nexport function stringToBase64URL(str) {\n  const base64 = [];\n  const emitter = char => {\n    base64.push(char);\n  };\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  stringToUTF8(str, byte => {\n    byteToBase64URL(byte, state, emitter);\n  });\n  byteToBase64URL(null, state, emitter);\n  return base64.join('');\n}\n/**\r\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\r\n * that the underlying string has been encoded as UTF-8.\r\n *\r\n * @param str The Base64-URL encoded string.\r\n */\nexport function stringFromBase64URL(str) {\n  const conv = [];\n  const utf8Emit = codepoint => {\n    conv.push(String.fromCodePoint(codepoint));\n  };\n  const utf8State = {\n    utf8seq: 0,\n    codepoint: 0\n  };\n  const b64State = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const byteEmit = byte => {\n    stringFromUTF8(byte, utf8State, utf8Emit);\n  };\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit);\n  }\n  return conv.join('');\n}\n/**\r\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\r\n *\r\n * @param codepoint The Unicode codepoint.\r\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\r\n */\nexport function codepointToUTF8(codepoint, emit) {\n  if (codepoint <= 0x7f) {\n    emit(codepoint);\n    return;\n  } else if (codepoint <= 0x7ff) {\n    emit(0xc0 | codepoint >> 6);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0xffff) {\n    emit(0xe0 | codepoint >> 12);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  } else if (codepoint <= 0x10ffff) {\n    emit(0xf0 | codepoint >> 18);\n    emit(0x80 | codepoint >> 12 & 0x3f);\n    emit(0x80 | codepoint >> 6 & 0x3f);\n    emit(0x80 | codepoint & 0x3f);\n    return;\n  }\n  throw new Error(\"Unrecognized Unicode codepoint: \".concat(codepoint.toString(16)));\n}\n/**\r\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\r\n *\r\n * @param str  The string to convert to UTF-8.\r\n * @param emit Function which will be called for each UTF-8 byte of the string.\r\n */\nexport function stringToUTF8(str, emit) {\n  for (let i = 0; i < str.length; i += 1) {\n    let codepoint = str.charCodeAt(i);\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\n      // range where the next UTF-16 codepoint needs to be combined with the\n      // current one to get the Unicode codepoint\n      const highSurrogate = (codepoint - 0xd800) * 0x400 & 0xffff;\n      const lowSurrogate = str.charCodeAt(i + 1) - 0xdc00 & 0xffff;\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000;\n      i += 1;\n    }\n    codepointToUTF8(codepoint, emit);\n  }\n}\n/**\r\n * Converts a UTF-8 byte to a Unicode codepoint.\r\n *\r\n * @param byte  The UTF-8 byte next in the sequence.\r\n * @param state The shared state between consecutive UTF-8 bytes in the\r\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\r\n * @param emit  Function which will be called for each codepoint.\r\n */\nexport function stringFromUTF8(byte, state, emit) {\n  if (state.utf8seq === 0) {\n    if (byte <= 0x7f) {\n      emit(byte);\n      return;\n    }\n    // count the number of 1 leading bits until you reach 0\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\n      if ((byte >> 7 - leadingBit & 1) === 0) {\n        state.utf8seq = leadingBit;\n        break;\n      }\n    }\n    if (state.utf8seq === 2) {\n      state.codepoint = byte & 31;\n    } else if (state.utf8seq === 3) {\n      state.codepoint = byte & 15;\n    } else if (state.utf8seq === 4) {\n      state.codepoint = byte & 7;\n    } else {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n    state.utf8seq -= 1;\n  } else if (state.utf8seq > 0) {\n    if (byte <= 0x7f) {\n      throw new Error('Invalid UTF-8 sequence');\n    }\n    state.codepoint = state.codepoint << 6 | byte & 63;\n    state.utf8seq -= 1;\n    if (state.utf8seq === 0) {\n      emit(state.codepoint);\n    }\n  }\n}\n/**\r\n * Helper functions to convert different types of strings to Uint8Array\r\n */\nexport function base64UrlToUint8Array(str) {\n  const result = [];\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const onByte = byte => {\n    result.push(byte);\n  };\n  for (let i = 0; i < str.length; i += 1) {\n    byteFromBase64URL(str.charCodeAt(i), state, onByte);\n  }\n  return new Uint8Array(result);\n}\nexport function stringToUint8Array(str) {\n  const result = [];\n  stringToUTF8(str, byte => result.push(byte));\n  return new Uint8Array(result);\n}\nexport function bytesToBase64URL(bytes) {\n  const result = [];\n  const state = {\n    queue: 0,\n    queuedBits: 0\n  };\n  const onChar = char => {\n    result.push(char);\n  };\n  bytes.forEach(byte => byteToBase64URL(byte, state, onChar));\n  // always call with `null` after processing all bytes\n  byteToBase64URL(null, state, onChar);\n  return result.join('');\n}","map":{"version":3,"names":["TO_BASE64URL","split","IGNORE_BASE64URL","FROM_BASE64URL","charMap","Array","i","length","charCodeAt","byteToBase64URL","byte","state","emit","queue","queuedBits","pos","byteFromBase64URL","charCode","bits","Error","concat","String","fromCharCode","stringToBase64URL","str","base64","emitter","char","push","stringToUTF8","join","stringFromBase64URL","conv","utf8Emit","codepoint","fromCodePoint","utf8State","utf8seq","b64State","byteEmit","stringFromUTF8","codepointToUTF8","toString","highSurrogate","lowSurrogate","leadingBit","base64UrlToUint8Array","result","onByte","Uint8Array","stringToUint8Array","bytesToBase64URL","bytes","onChar","forEach"],"sources":["C:\\Users\\bread\\Downloads\\html\\web_ban_sach\\node_modules\\@supabase\\auth-js\\src\\lib\\base64url.ts"],"sourcesContent":["/**\r\n * Avoid modifying this file. It's part of\r\n * https://github.com/supabase-community/base64url-js.  Submit all fixes on\r\n * that repo!\r\n */\r\n\r\nimport { Uint8Array_ } from './webauthn.dom'\r\n\r\n/**\r\n * An array of characters that encode 6 bits into a Base64-URL alphabet\r\n * character.\r\n */\r\nconst TO_BASE64URL = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_'.split('')\r\n\r\n/**\r\n * An array of characters that can appear in a Base64-URL encoded string but\r\n * should be ignored.\r\n */\r\nconst IGNORE_BASE64URL = ' \\t\\n\\r='.split('')\r\n\r\n/**\r\n * An array of 128 numbers that map a Base64-URL character to 6 bits, or if -2\r\n * used to skip the character, or if -1 used to error out.\r\n */\r\nconst FROM_BASE64URL = (() => {\r\n  const charMap: number[] = new Array(128)\r\n\r\n  for (let i = 0; i < charMap.length; i += 1) {\r\n    charMap[i] = -1\r\n  }\r\n\r\n  for (let i = 0; i < IGNORE_BASE64URL.length; i += 1) {\r\n    charMap[IGNORE_BASE64URL[i].charCodeAt(0)] = -2\r\n  }\r\n\r\n  for (let i = 0; i < TO_BASE64URL.length; i += 1) {\r\n    charMap[TO_BASE64URL[i].charCodeAt(0)] = i\r\n  }\r\n\r\n  return charMap\r\n})()\r\n\r\n/**\r\n * Converts a byte to a Base64-URL string.\r\n *\r\n * @param byte The byte to convert, or null to flush at the end of the byte sequence.\r\n * @param state The Base64 conversion state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next Base64 character when ready.\r\n */\r\nexport function byteToBase64URL(\r\n  byte: number | null,\r\n  state: { queue: number; queuedBits: number },\r\n  emit: (char: string) => void\r\n) {\r\n  if (byte !== null) {\r\n    state.queue = (state.queue << 8) | byte\r\n    state.queuedBits += 8\r\n\r\n    while (state.queuedBits >= 6) {\r\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\r\n      emit(TO_BASE64URL[pos])\r\n      state.queuedBits -= 6\r\n    }\r\n  } else if (state.queuedBits > 0) {\r\n    state.queue = state.queue << (6 - state.queuedBits)\r\n    state.queuedBits = 6\r\n\r\n    while (state.queuedBits >= 6) {\r\n      const pos = (state.queue >> (state.queuedBits - 6)) & 63\r\n      emit(TO_BASE64URL[pos])\r\n      state.queuedBits -= 6\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a String char code (extracted using `string.charCodeAt(position)`) to a sequence of Base64-URL characters.\r\n *\r\n * @param charCode The char code of the JavaScript string.\r\n * @param state The Base64 state. Pass an initial value of `{ queue: 0, queuedBits: 0 }`.\r\n * @param emit A function called with the next byte.\r\n */\r\nexport function byteFromBase64URL(\r\n  charCode: number,\r\n  state: { queue: number; queuedBits: number },\r\n  emit: (byte: number) => void\r\n) {\r\n  const bits = FROM_BASE64URL[charCode]\r\n\r\n  if (bits > -1) {\r\n    // valid Base64-URL character\r\n    state.queue = (state.queue << 6) | bits\r\n    state.queuedBits += 6\r\n\r\n    while (state.queuedBits >= 8) {\r\n      emit((state.queue >> (state.queuedBits - 8)) & 0xff)\r\n      state.queuedBits -= 8\r\n    }\r\n  } else if (bits === -2) {\r\n    // ignore spaces, tabs, newlines, =\r\n    return\r\n  } else {\r\n    throw new Error(`Invalid Base64-URL character \"${String.fromCharCode(charCode)}\"`)\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a JavaScript string (which may include any valid character) into a\r\n * Base64-URL encoded string. The string is first encoded in UTF-8 which is\r\n * then encoded as Base64-URL.\r\n *\r\n * @param str The string to convert.\r\n */\r\nexport function stringToBase64URL(str: string) {\r\n  const base64: string[] = []\r\n\r\n  const emitter = (char: string) => {\r\n    base64.push(char)\r\n  }\r\n\r\n  const state = { queue: 0, queuedBits: 0 }\r\n\r\n  stringToUTF8(str, (byte: number) => {\r\n    byteToBase64URL(byte, state, emitter)\r\n  })\r\n\r\n  byteToBase64URL(null, state, emitter)\r\n\r\n  return base64.join('')\r\n}\r\n\r\n/**\r\n * Converts a Base64-URL encoded string into a JavaScript string. It is assumed\r\n * that the underlying string has been encoded as UTF-8.\r\n *\r\n * @param str The Base64-URL encoded string.\r\n */\r\nexport function stringFromBase64URL(str: string) {\r\n  const conv: string[] = []\r\n\r\n  const utf8Emit = (codepoint: number) => {\r\n    conv.push(String.fromCodePoint(codepoint))\r\n  }\r\n\r\n  const utf8State = {\r\n    utf8seq: 0,\r\n    codepoint: 0,\r\n  }\r\n\r\n  const b64State = { queue: 0, queuedBits: 0 }\r\n\r\n  const byteEmit = (byte: number) => {\r\n    stringFromUTF8(byte, utf8State, utf8Emit)\r\n  }\r\n\r\n  for (let i = 0; i < str.length; i += 1) {\r\n    byteFromBase64URL(str.charCodeAt(i), b64State, byteEmit)\r\n  }\r\n\r\n  return conv.join('')\r\n}\r\n\r\n/**\r\n * Converts a Unicode codepoint to a multi-byte UTF-8 sequence.\r\n *\r\n * @param codepoint The Unicode codepoint.\r\n * @param emit      Function which will be called for each UTF-8 byte that represents the codepoint.\r\n */\r\nexport function codepointToUTF8(codepoint: number, emit: (byte: number) => void) {\r\n  if (codepoint <= 0x7f) {\r\n    emit(codepoint)\r\n    return\r\n  } else if (codepoint <= 0x7ff) {\r\n    emit(0xc0 | (codepoint >> 6))\r\n    emit(0x80 | (codepoint & 0x3f))\r\n    return\r\n  } else if (codepoint <= 0xffff) {\r\n    emit(0xe0 | (codepoint >> 12))\r\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\r\n    emit(0x80 | (codepoint & 0x3f))\r\n    return\r\n  } else if (codepoint <= 0x10ffff) {\r\n    emit(0xf0 | (codepoint >> 18))\r\n    emit(0x80 | ((codepoint >> 12) & 0x3f))\r\n    emit(0x80 | ((codepoint >> 6) & 0x3f))\r\n    emit(0x80 | (codepoint & 0x3f))\r\n    return\r\n  }\r\n\r\n  throw new Error(`Unrecognized Unicode codepoint: ${codepoint.toString(16)}`)\r\n}\r\n\r\n/**\r\n * Converts a JavaScript string to a sequence of UTF-8 bytes.\r\n *\r\n * @param str  The string to convert to UTF-8.\r\n * @param emit Function which will be called for each UTF-8 byte of the string.\r\n */\r\nexport function stringToUTF8(str: string, emit: (byte: number) => void) {\r\n  for (let i = 0; i < str.length; i += 1) {\r\n    let codepoint = str.charCodeAt(i)\r\n\r\n    if (codepoint > 0xd7ff && codepoint <= 0xdbff) {\r\n      // most UTF-16 codepoints are Unicode codepoints, except values in this\r\n      // range where the next UTF-16 codepoint needs to be combined with the\r\n      // current one to get the Unicode codepoint\r\n      const highSurrogate = ((codepoint - 0xd800) * 0x400) & 0xffff\r\n      const lowSurrogate = (str.charCodeAt(i + 1) - 0xdc00) & 0xffff\r\n      codepoint = (lowSurrogate | highSurrogate) + 0x10000\r\n      i += 1\r\n    }\r\n\r\n    codepointToUTF8(codepoint, emit)\r\n  }\r\n}\r\n\r\n/**\r\n * Converts a UTF-8 byte to a Unicode codepoint.\r\n *\r\n * @param byte  The UTF-8 byte next in the sequence.\r\n * @param state The shared state between consecutive UTF-8 bytes in the\r\n *              sequence, an object with the shape `{ utf8seq: 0, codepoint: 0 }`.\r\n * @param emit  Function which will be called for each codepoint.\r\n */\r\nexport function stringFromUTF8(\r\n  byte: number,\r\n  state: { utf8seq: number; codepoint: number },\r\n  emit: (codepoint: number) => void\r\n) {\r\n  if (state.utf8seq === 0) {\r\n    if (byte <= 0x7f) {\r\n      emit(byte)\r\n      return\r\n    }\r\n\r\n    // count the number of 1 leading bits until you reach 0\r\n    for (let leadingBit = 1; leadingBit < 6; leadingBit += 1) {\r\n      if (((byte >> (7 - leadingBit)) & 1) === 0) {\r\n        state.utf8seq = leadingBit\r\n        break\r\n      }\r\n    }\r\n\r\n    if (state.utf8seq === 2) {\r\n      state.codepoint = byte & 31\r\n    } else if (state.utf8seq === 3) {\r\n      state.codepoint = byte & 15\r\n    } else if (state.utf8seq === 4) {\r\n      state.codepoint = byte & 7\r\n    } else {\r\n      throw new Error('Invalid UTF-8 sequence')\r\n    }\r\n\r\n    state.utf8seq -= 1\r\n  } else if (state.utf8seq > 0) {\r\n    if (byte <= 0x7f) {\r\n      throw new Error('Invalid UTF-8 sequence')\r\n    }\r\n\r\n    state.codepoint = (state.codepoint << 6) | (byte & 63)\r\n    state.utf8seq -= 1\r\n\r\n    if (state.utf8seq === 0) {\r\n      emit(state.codepoint)\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Helper functions to convert different types of strings to Uint8Array\r\n */\r\n\r\nexport function base64UrlToUint8Array(str: string): Uint8Array_ {\r\n  const result: number[] = []\r\n  const state = { queue: 0, queuedBits: 0 }\r\n\r\n  const onByte = (byte: number) => {\r\n    result.push(byte)\r\n  }\r\n\r\n  for (let i = 0; i < str.length; i += 1) {\r\n    byteFromBase64URL(str.charCodeAt(i), state, onByte)\r\n  }\r\n\r\n  return new Uint8Array(result)\r\n}\r\n\r\nexport function stringToUint8Array(str: string): Uint8Array_ {\r\n  const result: number[] = []\r\n  stringToUTF8(str, (byte: number) => result.push(byte))\r\n  return new Uint8Array(result)\r\n}\r\n\r\nexport function bytesToBase64URL(bytes: Uint8Array) {\r\n  const result: string[] = []\r\n  const state = { queue: 0, queuedBits: 0 }\r\n\r\n  const onChar = (char: string) => {\r\n    result.push(char)\r\n  }\r\n\r\n  bytes.forEach((byte) => byteToBase64URL(byte, state, onChar))\r\n\r\n  // always call with `null` after processing all bytes\r\n  byteToBase64URL(null, state, onChar)\r\n\r\n  return result.join('')\r\n}\r\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}