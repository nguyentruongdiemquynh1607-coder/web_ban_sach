{"ast":null,"code":"const WeakPasswordReasons = ['length', 'characters', 'pwned'];\nconst AMRMethods = ['password', 'otp', 'oauth', 'totp', 'mfa/totp', 'mfa/phone', 'mfa/webauthn', 'anonymous', 'sso/saml', 'magiclink', 'web3'];\nconst FactorTypes = ['totp', 'phone', 'webauthn'];\nconst FactorVerificationStatuses = ['verified', 'unverified'];\nconst MFATOTPChannels = ['sms', 'whatsapp'];\nexport const SIGN_OUT_SCOPES = ['global', 'local', 'others'];","map":{"version":3,"names":["WeakPasswordReasons","AMRMethods","FactorTypes","FactorVerificationStatuses","MFATOTPChannels","SIGN_OUT_SCOPES"],"sources":["C:\\Users\\bread\\Downloads\\html\\web_ban_sach\\node_modules\\@supabase\\auth-js\\src\\lib\\types.ts"],"sourcesContent":["import { AuthError } from './errors'\r\nimport { Fetch } from './fetch'\r\nimport { EIP1193Provider, EthereumSignInInput, Hex } from './web3/ethereum'\r\nimport type { SolanaSignInInput, SolanaSignInOutput } from './web3/solana'\r\nimport {\r\n  ServerCredentialCreationOptions,\r\n  ServerCredentialRequestOptions,\r\n  WebAuthnApi,\r\n} from './webauthn'\r\nimport {\r\n  AuthenticationCredential,\r\n  PublicKeyCredentialCreationOptionsFuture,\r\n  PublicKeyCredentialRequestOptionsFuture,\r\n  RegistrationCredential,\r\n} from './webauthn.dom'\r\n\r\n/** One of the providers supported by GoTrue. */\r\nexport type Provider =\r\n  | 'apple'\r\n  | 'azure'\r\n  | 'bitbucket'\r\n  | 'discord'\r\n  | 'facebook'\r\n  | 'figma'\r\n  | 'github'\r\n  | 'gitlab'\r\n  | 'google'\r\n  | 'kakao'\r\n  | 'keycloak'\r\n  | 'linkedin'\r\n  | 'linkedin_oidc'\r\n  | 'notion'\r\n  | 'slack'\r\n  | 'slack_oidc'\r\n  | 'spotify'\r\n  | 'twitch'\r\n  | 'twitter'\r\n  | 'workos'\r\n  | 'zoom'\r\n  | 'fly'\r\n\r\nexport type AuthChangeEventMFA = 'MFA_CHALLENGE_VERIFIED'\r\n\r\nexport type AuthChangeEvent =\r\n  | 'INITIAL_SESSION'\r\n  | 'PASSWORD_RECOVERY'\r\n  | 'SIGNED_IN'\r\n  | 'SIGNED_OUT'\r\n  | 'TOKEN_REFRESHED'\r\n  | 'USER_UPDATED'\r\n  | AuthChangeEventMFA\r\n\r\n/**\r\n * Provide your own global lock implementation instead of the default\r\n * implementation. The function should acquire a lock for the duration of the\r\n * `fn` async function, such that no other client instances will be able to\r\n * hold it at the same time.\r\n *\r\n * @experimental\r\n *\r\n * @param name Name of the lock to be acquired.\r\n * @param acquireTimeout If negative, no timeout should occur. If positive it\r\n *                       should throw an Error with an `isAcquireTimeout`\r\n *                       property set to true if the operation fails to be\r\n *                       acquired after this much time (ms).\r\n * @param fn The operation to execute when the lock is acquired.\r\n */\r\nexport type LockFunc = <R>(name: string, acquireTimeout: number, fn: () => Promise<R>) => Promise<R>\r\n\r\nexport type GoTrueClientOptions = {\r\n  /* The URL of the GoTrue server. */\r\n  url?: string\r\n  /* Any additional headers to send to the GoTrue server. */\r\n  headers?: { [key: string]: string }\r\n  /* Optional key name used for storing tokens in local storage. */\r\n  storageKey?: string\r\n  /* Set to \"true\" if you want to automatically detects OAuth grants in the URL and signs in the user. */\r\n  detectSessionInUrl?: boolean\r\n  /* Set to \"true\" if you want to automatically refresh the token before expiring. */\r\n  autoRefreshToken?: boolean\r\n  /* Set to \"true\" if you want to automatically save the user session into local storage. If set to false, session will just be saved in memory. */\r\n  persistSession?: boolean\r\n  /* Provide your own local storage implementation to use instead of the browser's local storage. */\r\n  storage?: SupportedStorage\r\n  /**\r\n   * Stores the user object in a separate storage location from the rest of the session data. When non-null, `storage` will only store a JSON object containing the access and refresh token and some adjacent metadata, while `userStorage` will only contain the user object under the key `storageKey + '-user'`.\r\n   *\r\n   * When this option is set and cookie storage is used, `getSession()` and other functions that load a session from the cookie store might not return back a user. It's very important to always use `getUser()` to fetch a user object in those scenarios.\r\n   *\r\n   * @experimental\r\n   */\r\n  userStorage?: SupportedStorage\r\n  /* A custom fetch implementation. */\r\n  fetch?: Fetch\r\n  /* If set to 'pkce' PKCE flow. Defaults to the 'implicit' flow otherwise */\r\n  flowType?: AuthFlowType\r\n  /* If debug messages are emitted. Can be used to inspect the behavior of the library. If set to a function, the provided function will be used instead of `console.log()` to perform the logging. */\r\n  debug?: boolean | ((message: string, ...args: any[]) => void)\r\n  /**\r\n   * Provide your own locking mechanism based on the environment. By default no locking is done at this time.\r\n   *\r\n   * @experimental\r\n   */\r\n  lock?: LockFunc\r\n  /**\r\n   * Set to \"true\" if there is a custom authorization header set globally.\r\n   * @experimental\r\n   */\r\n  hasCustomAuthorizationHeader?: boolean\r\n}\r\n\r\nconst WeakPasswordReasons = ['length', 'characters', 'pwned'] as const\r\n\r\nexport type WeakPasswordReasons = (typeof WeakPasswordReasons)[number]\r\nexport type WeakPassword = {\r\n  reasons: WeakPasswordReasons[]\r\n  message: string\r\n}\r\n\r\n/**\r\n * Resolve mapped types and show the derived keys and their types when hovering in\r\n * VS Code, instead of just showing the names those mapped types are defined with.\r\n */\r\nexport type Prettify<T> = T extends Function ? T : { [K in keyof T]: T[K] }\r\n\r\n/**\r\n * A stricter version of TypeScript's Omit that only allows omitting keys that actually exist.\r\n * This prevents typos and ensures type safety at compile time.\r\n * Unlike regular Omit, this will error if you try to omit a non-existent key.\r\n */\r\nexport type StrictOmit<T, K extends keyof T> = Omit<T, K>\r\n\r\n/**\r\n * a shared result type that encapsulates errors instead of throwing them, allows you to optionally specify the ErrorType\r\n */\r\nexport type RequestResult<T, ErrorType extends Error = AuthError> =\r\n  | {\r\n      data: T\r\n      error: null\r\n    }\r\n  | {\r\n      data: null\r\n      error: Error extends AuthError ? AuthError : ErrorType\r\n    }\r\n\r\n/**\r\n * similar to RequestResult except it allows you to destructure the possible shape of the success response\r\n *  {@see RequestResult}\r\n */\r\nexport type RequestResultSafeDestructure<T> =\r\n  | { data: T; error: null }\r\n  | {\r\n      data: T extends object ? { [K in keyof T]: null } : null\r\n      error: AuthError\r\n    }\r\n\r\nexport type AuthResponse = RequestResultSafeDestructure<{\r\n  user: User | null\r\n  session: Session | null\r\n}>\r\n\r\nexport type AuthResponsePassword = RequestResultSafeDestructure<{\r\n  user: User | null\r\n  session: Session | null\r\n  weak_password?: WeakPassword | null\r\n}>\r\n\r\n/**\r\n * AuthOtpResponse is returned when OTP is used.\r\n *\r\n * {@see AuthResponse}\r\n */\r\nexport type AuthOtpResponse = RequestResultSafeDestructure<{\r\n  user: null\r\n  session: null\r\n  messageId?: string | null\r\n}>\r\n\r\nexport type AuthTokenResponse = RequestResultSafeDestructure<{\r\n  user: User\r\n  session: Session\r\n}>\r\n\r\nexport type AuthTokenResponsePassword = RequestResultSafeDestructure<{\r\n  user: User\r\n  session: Session\r\n  weakPassword?: WeakPassword\r\n}>\r\n\r\nexport type OAuthResponse =\r\n  | {\r\n      data: {\r\n        provider: Provider\r\n        url: string\r\n      }\r\n      error: null\r\n    }\r\n  | {\r\n      data: {\r\n        provider: Provider\r\n        url: null\r\n      }\r\n      error: AuthError\r\n    }\r\n\r\nexport type SSOResponse = RequestResult<{\r\n  /**\r\n   * URL to open in a browser which will complete the sign-in flow by\r\n   * taking the user to the identity provider's authentication flow.\r\n   *\r\n   * On browsers you can set the URL to `window.location.href` to take\r\n   * the user to the authentication flow.\r\n   */\r\n  url: string\r\n}>\r\n\r\nexport type UserResponse = RequestResultSafeDestructure<{\r\n  user: User\r\n}>\r\n\r\nexport interface Session {\r\n  /**\r\n   * The oauth provider token. If present, this can be used to make external API requests to the oauth provider used.\r\n   */\r\n  provider_token?: string | null\r\n  /**\r\n   * The oauth provider refresh token. If present, this can be used to refresh the provider_token via the oauth provider's API.\r\n   * Not all oauth providers return a provider refresh token. If the provider_refresh_token is missing, please refer to the oauth provider's documentation for information on how to obtain the provider refresh token.\r\n   */\r\n  provider_refresh_token?: string | null\r\n  /**\r\n   * The access token jwt. It is recommended to set the JWT_EXPIRY to a shorter expiry value.\r\n   */\r\n  access_token: string\r\n  /**\r\n   * A one-time used refresh token that never expires.\r\n   */\r\n  refresh_token: string\r\n  /**\r\n   * The number of seconds until the token expires (since it was issued). Returned when a login is confirmed.\r\n   */\r\n  expires_in: number\r\n  /**\r\n   * A timestamp of when the token will expire. Returned when a login is confirmed.\r\n   */\r\n  expires_at?: number\r\n  token_type: 'bearer'\r\n\r\n  /**\r\n   * When using a separate user storage, accessing properties of this object will throw an error.\r\n   */\r\n  user: User\r\n}\r\n\r\nconst AMRMethods = [\r\n  'password',\r\n  'otp',\r\n  'oauth',\r\n  'totp',\r\n  'mfa/totp',\r\n  'mfa/phone',\r\n  'mfa/webauthn',\r\n  'anonymous',\r\n  'sso/saml',\r\n  'magiclink',\r\n  'web3',\r\n] as const\r\n\r\nexport type AMRMethod = (typeof AMRMethods)[number] | (string & {})\r\n\r\n/**\r\n * An authentication methord reference (AMR) entry.\r\n *\r\n * An entry designates what method was used by the user to verify their\r\n * identity and at what time.\r\n *\r\n * @see {@link GoTrueMFAApi#getAuthenticatorAssuranceLevel}.\r\n */\r\nexport interface AMREntry {\r\n  /** Authentication method name. */\r\n  method: AMRMethod\r\n\r\n  /**\r\n   * Timestamp when the method was successfully used. Represents number of\r\n   * seconds since 1st January 1970 (UNIX epoch) in UTC.\r\n   */\r\n  timestamp: number\r\n}\r\n\r\nexport interface UserIdentity {\r\n  id: string\r\n  user_id: string\r\n  identity_data?: {\r\n    [key: string]: any\r\n  }\r\n  identity_id: string\r\n  provider: string\r\n  created_at?: string\r\n  last_sign_in_at?: string\r\n  updated_at?: string\r\n}\r\n\r\nconst FactorTypes = ['totp', 'phone', 'webauthn'] as const\r\n\r\n/**\r\n * Type of factor. `totp` and `phone` supported with this version\r\n */\r\nexport type FactorType = (typeof FactorTypes)[number]\r\n\r\nconst FactorVerificationStatuses = ['verified', 'unverified'] as const\r\n\r\n/**\r\n * The verification status of the factor, default is `unverified` after `.enroll()`, then `verified` after the user verifies it with `.verify()`\r\n */\r\ntype FactorVerificationStatus = (typeof FactorVerificationStatuses)[number]\r\n\r\n/**\r\n * A MFA factor.\r\n *\r\n * @see {@link GoTrueMFAApi#enroll}\r\n * @see {@link GoTrueMFAApi#listFactors}\r\n * @see {@link GoTrueMFAAdminApi#listFactors}\r\n */\r\nexport type Factor<\r\n  Type extends FactorType = FactorType,\r\n  Status extends FactorVerificationStatus = (typeof FactorVerificationStatuses)[number],\r\n> = {\r\n  /** ID of the factor. */\r\n  id: string\r\n\r\n  /** Friendly name of the factor, useful to disambiguate between multiple factors. */\r\n  friendly_name?: string\r\n\r\n  /**\r\n   * Type of factor. `totp` and `phone` supported with this version\r\n   */\r\n  factor_type: Type\r\n\r\n  /**\r\n   * The verification status of the factor, default is `unverified` after `.enroll()`, then `verified` after the user verifies it with `.verify()`\r\n   */\r\n  status: Status\r\n\r\n  created_at: string\r\n  updated_at: string\r\n}\r\n\r\nexport interface UserAppMetadata {\r\n  provider?: string\r\n  [key: string]: any\r\n}\r\n\r\nexport interface UserMetadata {\r\n  [key: string]: any\r\n}\r\n\r\nexport interface User {\r\n  id: string\r\n  app_metadata: UserAppMetadata\r\n  user_metadata: UserMetadata\r\n  aud: string\r\n  confirmation_sent_at?: string\r\n  recovery_sent_at?: string\r\n  email_change_sent_at?: string\r\n  new_email?: string\r\n  new_phone?: string\r\n  invited_at?: string\r\n  action_link?: string\r\n  email?: string\r\n  phone?: string\r\n  created_at: string\r\n  confirmed_at?: string\r\n  email_confirmed_at?: string\r\n  phone_confirmed_at?: string\r\n  last_sign_in_at?: string\r\n  role?: string\r\n  updated_at?: string\r\n  identities?: UserIdentity[]\r\n  is_anonymous?: boolean\r\n  is_sso_user?: boolean\r\n  factors?: (Factor<FactorType, 'verified'> | Factor<FactorType, 'unverified'>)[]\r\n  deleted_at?: string\r\n}\r\n\r\nexport interface UserAttributes {\r\n  /**\r\n   * The user's email.\r\n   */\r\n  email?: string\r\n\r\n  /**\r\n   * The user's phone.\r\n   */\r\n  phone?: string\r\n\r\n  /**\r\n   * The user's password.\r\n   */\r\n  password?: string\r\n\r\n  /**\r\n   * The nonce sent for reauthentication if the user's password is to be updated.\r\n   *\r\n   * Call reauthenticate() to obtain the nonce first.\r\n   */\r\n  nonce?: string\r\n\r\n  /**\r\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n   *\r\n   * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n   *\r\n   */\r\n  data?: object\r\n}\r\n\r\nexport interface AdminUserAttributes extends Omit<UserAttributes, 'data'> {\r\n  /**\r\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n   *\r\n   *\r\n   * The `user_metadata` should be a JSON object that includes user-specific info, such as their first and last name.\r\n   *\r\n   * Note: When using the GoTrueAdminApi and wanting to modify a user's metadata,\r\n   * this attribute is used instead of UserAttributes data.\r\n   *\r\n   */\r\n  user_metadata?: object\r\n\r\n  /**\r\n   * A custom data object to store the user's application specific metadata. This maps to the `auth.users.app_metadata` column.\r\n   *\r\n   * Only a service role can modify.\r\n   *\r\n   * The `app_metadata` should be a JSON object that includes app-specific info, such as identity providers, roles, and other\r\n   * access control information.\r\n   */\r\n  app_metadata?: object\r\n\r\n  /**\r\n   * Confirms the user's email address if set to true.\r\n   *\r\n   * Only a service role can modify.\r\n   */\r\n  email_confirm?: boolean\r\n\r\n  /**\r\n   * Confirms the user's phone number if set to true.\r\n   *\r\n   * Only a service role can modify.\r\n   */\r\n  phone_confirm?: boolean\r\n\r\n  /**\r\n   * Determines how long a user is banned for.\r\n   *\r\n   * The format for the ban duration follows a strict sequence of decimal numbers with a unit suffix.\r\n   * Valid time units are \"ns\", \"us\" (or \"Âµs\"), \"ms\", \"s\", \"m\", \"h\".\r\n   *\r\n   * For example, some possible durations include: '300ms', '2h45m'.\r\n   *\r\n   * Setting the ban duration to 'none' lifts the ban on the user.\r\n   */\r\n  ban_duration?: string | 'none'\r\n\r\n  /**\r\n   * The `role` claim set in the user's access token JWT.\r\n   *\r\n   * When a user signs up, this role is set to `authenticated` by default. You should only modify the `role` if you need to provision several levels of admin access that have different permissions on individual columns in your database.\r\n   *\r\n   * Setting this role to `service_role` is not recommended as it grants the user admin privileges.\r\n   */\r\n  role?: string\r\n\r\n  /**\r\n   * The `password_hash` for the user's password.\r\n   *\r\n   * Allows you to specify a password hash for the user. This is useful for migrating a user's password hash from another service.\r\n   *\r\n   * Supports bcrypt, scrypt (firebase), and argon2 password hashes.\r\n   */\r\n  password_hash?: string\r\n\r\n  /**\r\n   * The `id` for the user.\r\n   *\r\n   * Allows you to overwrite the default `id` set for the user.\r\n   */\r\n  id?: string\r\n}\r\n\r\nexport interface Subscription {\r\n  /**\r\n   * The subscriber UUID. This will be set by the client.\r\n   */\r\n  id: string\r\n  /**\r\n   * The function to call every time there is an event. eg: (eventName) => {}\r\n   */\r\n  callback: (event: AuthChangeEvent, session: Session | null) => void\r\n  /**\r\n   * Call this to remove the listener.\r\n   */\r\n  unsubscribe: () => void\r\n}\r\n\r\nexport type SignInAnonymouslyCredentials = {\r\n  options?: {\r\n    /**\r\n     * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n     *\r\n     * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n     */\r\n    data?: object\r\n    /** Verification token received when the user completes the captcha on the site. */\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport type SignUpWithPasswordCredentials = Prettify<\r\n  PasswordCredentialsBase & {\r\n    options?: {\r\n      emailRedirectTo?: string // only for email\r\n      data?: object\r\n      captchaToken?: string\r\n      channel?: 'sms' | 'whatsapp' // only for phone\r\n    }\r\n  }\r\n>\r\n\r\ntype PasswordCredentialsBase =\r\n  | { email: string; password: string }\r\n  | { phone: string; password: string }\r\n\r\nexport type SignInWithPasswordCredentials = PasswordCredentialsBase & {\r\n  options?: {\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport type SignInWithPasswordlessCredentials =\r\n  | {\r\n      /** The user's email address. */\r\n      email: string\r\n      options?: {\r\n        /** The redirect url embedded in the email link */\r\n        emailRedirectTo?: string\r\n        /** If set to false, this method will not create a new user. Defaults to true. */\r\n        shouldCreateUser?: boolean\r\n        /**\r\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n         *\r\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n         */\r\n        data?: object\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      /** The user's phone number. */\r\n      phone: string\r\n      options?: {\r\n        /** If set to false, this method will not create a new user. Defaults to true. */\r\n        shouldCreateUser?: boolean\r\n        /**\r\n         * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n         *\r\n         * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n         */\r\n        data?: object\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n        /** Messaging channel to use (e.g. whatsapp or sms) */\r\n        channel?: 'sms' | 'whatsapp'\r\n      }\r\n    }\r\n\r\nexport type AuthFlowType = 'implicit' | 'pkce'\r\nexport type SignInWithOAuthCredentials = {\r\n  /** One of the providers supported by GoTrue. */\r\n  provider: Provider\r\n  options?: {\r\n    /** A URL to send the user to after they are confirmed. */\r\n    redirectTo?: string\r\n    /** A space-separated list of scopes granted to the OAuth application. */\r\n    scopes?: string\r\n    /** An object of query params */\r\n    queryParams?: { [key: string]: string }\r\n    /** If set to true does not immediately redirect the current browser context to visit the OAuth authorization page for the provider. */\r\n    skipBrowserRedirect?: boolean\r\n  }\r\n}\r\n\r\nexport type SignInWithIdTokenCredentials = {\r\n  /** Provider name or OIDC `iss` value identifying which provider should be used to verify the provided token. Supported names: `google`, `apple`, `azure`, `facebook`, `kakao`, `keycloak` (deprecated). */\r\n  provider: 'google' | 'apple' | 'azure' | 'facebook' | 'kakao' | (string & {})\r\n  /** OIDC ID token issued by the specified provider. The `iss` claim in the ID token must match the supplied provider. Some ID tokens contain an `at_hash` which require that you provide an `access_token` value to be accepted properly. If the token contains a `nonce` claim you must supply the nonce used to obtain the ID token. */\r\n  token: string\r\n  /** If the ID token contains an `at_hash` claim, then the hash of this value is compared to the value in the ID token. */\r\n  access_token?: string\r\n  /** If the ID token contains a `nonce` claim, then the hash of this value is compared to the value in the ID token. */\r\n  nonce?: string\r\n  options?: {\r\n    /** Verification token received when the user completes the captcha on the site. */\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport type SolanaWallet = {\r\n  signIn?: (...inputs: SolanaSignInInput[]) => Promise<SolanaSignInOutput | SolanaSignInOutput[]>\r\n  publicKey?: {\r\n    toBase58: () => string\r\n  } | null\r\n\r\n  signMessage?: (message: Uint8Array, encoding?: 'utf8' | string) => Promise<Uint8Array> | undefined\r\n}\r\n\r\nexport type SolanaWeb3Credentials =\r\n  | {\r\n      chain: 'solana'\r\n\r\n      /** Wallet interface to use. If not specified will default to `window.solana`. */\r\n      wallet?: SolanaWallet\r\n\r\n      /** Optional statement to include in the Sign in with Solana message. Must not include new line characters. Most wallets like Phantom **require specifying a statement!** */\r\n      statement?: string\r\n\r\n      options?: {\r\n        /** URL to use with the wallet interface. Some wallets do not allow signing a message for URLs different from the current page. */\r\n        url?: string\r\n\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n\r\n        signInWithSolana?: Partial<\r\n          Omit<SolanaSignInInput, 'version' | 'chain' | 'domain' | 'uri' | 'statement'>\r\n        >\r\n      }\r\n    }\r\n  | {\r\n      chain: 'solana'\r\n\r\n      /** Sign in with Solana compatible message. Must include `Issued At`, `URI` and `Version`. */\r\n      message: string\r\n\r\n      /** Ed25519 signature of the message. */\r\n      signature: Uint8Array\r\n\r\n      options?: {\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type EthereumWallet = EIP1193Provider\r\n\r\nexport type EthereumWeb3Credentials =\r\n  | {\r\n      chain: 'ethereum'\r\n\r\n      /** Wallet interface to use. If not specified will default to `window.ethereum`. */\r\n      wallet?: EthereumWallet\r\n\r\n      /** Optional statement to include in the Sign in with Ethereum message. Must not include new line characters. Most wallets like Phantom **require specifying a statement!** */\r\n      statement?: string\r\n\r\n      options?: {\r\n        /** URL to use with the wallet interface. Some wallets do not allow signing a message for URLs different from the current page. */\r\n        url?: string\r\n\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n\r\n        signInWithEthereum?: Partial<\r\n          Omit<EthereumSignInInput, 'version' | 'domain' | 'uri' | 'statement'>\r\n        >\r\n      }\r\n    }\r\n  | {\r\n      chain: 'ethereum'\r\n\r\n      /** Sign in with Ethereum compatible message. Must include `Issued At`, `URI` and `Version`. */\r\n      message: string\r\n\r\n      /** Ethereum curve (secp256k1) signature of the message. */\r\n      signature: Hex\r\n\r\n      options?: {\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type Web3Credentials = SolanaWeb3Credentials | EthereumWeb3Credentials\r\n\r\nexport type VerifyOtpParams = VerifyMobileOtpParams | VerifyEmailOtpParams | VerifyTokenHashParams\r\nexport interface VerifyMobileOtpParams {\r\n  /** The user's phone number. */\r\n  phone: string\r\n  /** The otp sent to the user's phone number. */\r\n  token: string\r\n  /** The user's verification type. */\r\n  type: MobileOtpType\r\n  options?: {\r\n    /** A URL to send the user to after they are confirmed. */\r\n    redirectTo?: string\r\n\r\n    /**\r\n     * Verification token received when the user completes the captcha on the site.\r\n     *\r\n     * @deprecated\r\n     */\r\n    captchaToken?: string\r\n  }\r\n}\r\nexport interface VerifyEmailOtpParams {\r\n  /** The user's email address. */\r\n  email: string\r\n  /** The otp sent to the user's email address. */\r\n  token: string\r\n  /** The user's verification type. */\r\n  type: EmailOtpType\r\n  options?: {\r\n    /** A URL to send the user to after they are confirmed. */\r\n    redirectTo?: string\r\n\r\n    /** Verification token received when the user completes the captcha on the site.\r\n     *\r\n     * @deprecated\r\n     */\r\n    captchaToken?: string\r\n  }\r\n}\r\n\r\nexport interface VerifyTokenHashParams {\r\n  /** The token hash used in an email link */\r\n  token_hash: string\r\n\r\n  /** The user's verification type. */\r\n  type: EmailOtpType\r\n}\r\n\r\nexport type MobileOtpType = 'sms' | 'phone_change'\r\nexport type EmailOtpType = 'signup' | 'invite' | 'magiclink' | 'recovery' | 'email_change' | 'email'\r\n\r\nexport type ResendParams =\r\n  | {\r\n      type: Extract<EmailOtpType, 'signup' | 'email_change'>\r\n      email: string\r\n      options?: {\r\n        /** A URL to send the user to after they have signed-in. */\r\n        emailRedirectTo?: string\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      type: Extract<MobileOtpType, 'sms' | 'phone_change'>\r\n      phone: string\r\n      options?: {\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type SignInWithSSO =\r\n  | {\r\n      /** UUID of the SSO provider to invoke single-sign on to. */\r\n      providerId: string\r\n\r\n      options?: {\r\n        /** A URL to send the user to after they have signed-in. */\r\n        redirectTo?: string\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n  | {\r\n      /** Domain name of the organization for which to invoke single-sign on. */\r\n      domain: string\r\n\r\n      options?: {\r\n        /** A URL to send the user to after they have signed-in. */\r\n        redirectTo?: string\r\n        /** Verification token received when the user completes the captcha on the site. */\r\n        captchaToken?: string\r\n      }\r\n    }\r\n\r\nexport type GenerateSignupLinkParams = {\r\n  type: 'signup'\r\n  email: string\r\n  password: string\r\n  options?: Pick<GenerateLinkOptions, 'data' | 'redirectTo'>\r\n}\r\n\r\nexport type GenerateInviteOrMagiclinkParams = {\r\n  type: 'invite' | 'magiclink'\r\n  /** The user's email */\r\n  email: string\r\n  options?: Pick<GenerateLinkOptions, 'data' | 'redirectTo'>\r\n}\r\n\r\nexport type GenerateRecoveryLinkParams = {\r\n  type: 'recovery'\r\n  /** The user's email */\r\n  email: string\r\n  options?: Pick<GenerateLinkOptions, 'redirectTo'>\r\n}\r\n\r\nexport type GenerateEmailChangeLinkParams = {\r\n  type: 'email_change_current' | 'email_change_new'\r\n  /** The user's email */\r\n  email: string\r\n  /**\r\n   * The user's new email. Only required if type is 'email_change_current' or 'email_change_new'.\r\n   */\r\n  newEmail: string\r\n  options?: Pick<GenerateLinkOptions, 'redirectTo'>\r\n}\r\n\r\nexport interface GenerateLinkOptions {\r\n  /**\r\n   * A custom data object to store the user's metadata. This maps to the `auth.users.raw_user_meta_data` column.\r\n   *\r\n   * The `data` should be a JSON object that includes user-specific info, such as their first and last name.\r\n   */\r\n  data?: object\r\n  /** The URL which will be appended to the email link generated. */\r\n  redirectTo?: string\r\n}\r\n\r\nexport type GenerateLinkParams =\r\n  | GenerateSignupLinkParams\r\n  | GenerateInviteOrMagiclinkParams\r\n  | GenerateRecoveryLinkParams\r\n  | GenerateEmailChangeLinkParams\r\n\r\nexport type GenerateLinkResponse = RequestResultSafeDestructure<{\r\n  properties: GenerateLinkProperties\r\n  user: User\r\n}>\r\n\r\n/** The properties related to the email link generated  */\r\nexport type GenerateLinkProperties = {\r\n  /**\r\n   * The email link to send to the user.\r\n   * The action_link follows the following format: auth/v1/verify?type={verification_type}&token={hashed_token}&redirect_to={redirect_to}\r\n   * */\r\n  action_link: string\r\n  /**\r\n   * The raw email OTP.\r\n   * You should send this in the email if you want your users to verify using an OTP instead of the action link.\r\n   * */\r\n  email_otp: string\r\n  /**\r\n   * The hashed token appended to the action link.\r\n   * */\r\n  hashed_token: string\r\n  /** The URL appended to the action link. */\r\n  redirect_to: string\r\n  /** The verification type that the email link is associated to. */\r\n  verification_type: GenerateLinkType\r\n}\r\n\r\nexport type GenerateLinkType =\r\n  | 'signup'\r\n  | 'invite'\r\n  | 'magiclink'\r\n  | 'recovery'\r\n  | 'email_change_current'\r\n  | 'email_change_new'\r\n\r\nexport type MFAEnrollParams = MFAEnrollTOTPParams | MFAEnrollPhoneParams | MFAEnrollWebauthnParams\r\n\r\nexport type MFAUnenrollParams = {\r\n  /** ID of the factor being unenrolled. */\r\n  factorId: string\r\n}\r\n\r\ntype MFAVerifyParamsBase = {\r\n  /** ID of the factor being verified. Returned in enroll(). */\r\n  factorId: string\r\n  /** ID of the challenge being verified. Returned in challenge(). */\r\n  challengeId: string\r\n}\r\n\r\ntype MFAVerifyTOTPParamFields = {\r\n  /** Verification code provided by the user. */\r\n  code: string\r\n}\r\n\r\nexport type MFAVerifyTOTPParams = Prettify<MFAVerifyParamsBase & MFAVerifyTOTPParamFields>\r\n\r\ntype MFAVerifyPhoneParamFields = MFAVerifyTOTPParamFields\r\n\r\nexport type MFAVerifyPhoneParams = Prettify<MFAVerifyParamsBase & MFAVerifyPhoneParamFields>\r\n\r\ntype MFAVerifyWebauthnParamFieldsBase = {\r\n  /** Relying party ID */\r\n  rpId: string\r\n  /** Relying party origins */\r\n  rpOrigins?: string[]\r\n}\r\n\r\ntype MFAVerifyWebauthnCredentialParamFields<T extends 'create' | 'request' = 'create' | 'request'> =\r\n  {\r\n    /** Operation type */\r\n    type: T\r\n    /** Creation response from the authenticator (for enrollment/unverified factors) */\r\n    credential_response: T extends 'create' ? RegistrationCredential : AuthenticationCredential\r\n  }\r\n\r\n/**\r\n * WebAuthn-specific fields for MFA verification.\r\n * Supports both credential creation (registration) and request (authentication) flows.\r\n * @template T - Type of WebAuthn operation: 'create' for registration, 'request' for authentication\r\n */\r\nexport type MFAVerifyWebauthnParamFields<T extends 'create' | 'request' = 'create' | 'request'> = {\r\n  webauthn: MFAVerifyWebauthnParamFieldsBase & MFAVerifyWebauthnCredentialParamFields<T>\r\n}\r\n\r\n/**\r\n * Parameters for WebAuthn MFA verification.\r\n * Used to verify WebAuthn credentials after challenge.\r\n * @template T - Type of WebAuthn operation: 'create' for registration, 'request' for authentication\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-verifying-assertion W3C WebAuthn Spec - Verifying an Authentication Assertion}\r\n */\r\nexport type MFAVerifyWebauthnParams<T extends 'create' | 'request' = 'create' | 'request'> =\r\n  Prettify<MFAVerifyParamsBase & MFAVerifyWebauthnParamFields<T>>\r\n\r\nexport type MFAVerifyParams = MFAVerifyTOTPParams | MFAVerifyPhoneParams | MFAVerifyWebauthnParams\r\n\r\ntype MFAChallengeParamsBase = {\r\n  /** ID of the factor to be challenged. Returned in enroll(). */\r\n  factorId: string\r\n}\r\n\r\nconst MFATOTPChannels = ['sms', 'whatsapp'] as const\r\nexport type MFATOTPChannel = (typeof MFATOTPChannels)[number]\r\n\r\nexport type MFAChallengeTOTPParams = Prettify<MFAChallengeParamsBase>\r\n\r\ntype MFAChallengePhoneParamFields<Channel extends MFATOTPChannel = MFATOTPChannel> = {\r\n  /** Messaging channel to use (e.g. whatsapp or sms). Only relevant for phone factors */\r\n  channel: Channel\r\n}\r\n\r\nexport type MFAChallengePhoneParams = Prettify<\r\n  MFAChallengeParamsBase & MFAChallengePhoneParamFields\r\n>\r\n\r\n/** WebAuthn parameters for WebAuthn factor challenge */\r\ntype MFAChallengeWebauthnParamFields = {\r\n  webauthn: {\r\n    /** Relying party ID */\r\n    rpId: string\r\n    /** Relying party origins*/\r\n    rpOrigins?: string[]\r\n  }\r\n}\r\n\r\n/**\r\n * Parameters for initiating a WebAuthn MFA challenge.\r\n * Includes Relying Party information needed for WebAuthn ceremonies.\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-rp-operations W3C WebAuthn Spec - Relying Party Operations}\r\n */\r\nexport type MFAChallengeWebauthnParams = Prettify<\r\n  MFAChallengeParamsBase & MFAChallengeWebauthnParamFields\r\n>\r\n\r\nexport type MFAChallengeParams =\r\n  | MFAChallengeTOTPParams\r\n  | MFAChallengePhoneParams\r\n  | MFAChallengeWebauthnParams\r\n\r\ntype MFAChallengeAndVerifyParamsBase = Omit<MFAVerifyParamsBase, 'challengeId'>\r\n\r\ntype MFAChallengeAndVerifyTOTPParamFields = MFAVerifyTOTPParamFields\r\n\r\ntype MFAChallengeAndVerifyTOTPParams = Prettify<\r\n  MFAChallengeAndVerifyParamsBase & MFAChallengeAndVerifyTOTPParamFields\r\n>\r\n\r\nexport type MFAChallengeAndVerifyParams = MFAChallengeAndVerifyTOTPParams\r\n\r\n/**\r\n * Data returned after successful MFA verification.\r\n * Contains new session tokens and updated user information.\r\n */\r\nexport type AuthMFAVerifyResponseData = {\r\n  /** New access token (JWT) after successful verification. */\r\n  access_token: string\r\n\r\n  /** Type of token, always `bearer`. */\r\n  token_type: 'bearer'\r\n\r\n  /** Number of seconds in which the access token will expire. */\r\n  expires_in: number\r\n\r\n  /** Refresh token you can use to obtain new access tokens when expired. */\r\n  refresh_token: string\r\n\r\n  /** Updated user profile. */\r\n  user: User\r\n}\r\n\r\n/**\r\n * Response type for MFA verification operations.\r\n * Returns session tokens on successful verification.\r\n */\r\nexport type AuthMFAVerifyResponse = RequestResult<AuthMFAVerifyResponseData>\r\n\r\nexport type AuthMFAEnrollResponse =\r\n  | AuthMFAEnrollTOTPResponse\r\n  | AuthMFAEnrollPhoneResponse\r\n  | AuthMFAEnrollWebauthnResponse\r\n\r\nexport type AuthMFAUnenrollResponse = RequestResult<{\r\n  /** ID of the factor that was successfully unenrolled. */\r\n  id: string\r\n}>\r\n\r\ntype AuthMFAChallengeResponseBase<T extends FactorType> = {\r\n  /** ID of the newly created challenge. */\r\n  id: string\r\n\r\n  /** Factor Type which generated the challenge */\r\n  type: T\r\n\r\n  /** Timestamp in UNIX seconds when this challenge will no longer be usable. */\r\n  expires_at: number\r\n}\r\n\r\ntype AuthMFAChallengeTOTPResponseFields = {\r\n  /** no extra fields for now, kept for consistency and for possible future changes  */\r\n}\r\n\r\nexport type AuthMFAChallengeTOTPResponse = RequestResult<\r\n  Prettify<AuthMFAChallengeResponseBase<'totp'> & AuthMFAChallengeTOTPResponseFields>\r\n>\r\n\r\ntype AuthMFAChallengePhoneResponseFields = {\r\n  /** no extra fields for now, kept for consistency and for possible future changes  */\r\n}\r\n\r\nexport type AuthMFAChallengePhoneResponse = RequestResult<\r\n  Prettify<AuthMFAChallengeResponseBase<'phone'> & AuthMFAChallengePhoneResponseFields>\r\n>\r\n\r\ntype AuthMFAChallengeWebauthnResponseFields = {\r\n  webauthn:\r\n    | {\r\n        type: 'create'\r\n        credential_options: { publicKey: PublicKeyCredentialCreationOptionsFuture }\r\n      }\r\n    | {\r\n        type: 'request'\r\n        credential_options: { publicKey: PublicKeyCredentialRequestOptionsFuture }\r\n      }\r\n}\r\n\r\n/**\r\n * Response type for WebAuthn MFA challenge.\r\n * Contains credential creation or request options from the server.\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-credential-creation W3C WebAuthn Spec - Credential Creation}\r\n */\r\nexport type AuthMFAChallengeWebauthnResponse = RequestResult<\r\n  Prettify<AuthMFAChallengeResponseBase<'webauthn'> & AuthMFAChallengeWebauthnResponseFields>\r\n>\r\n\r\ntype AuthMFAChallengeWebauthnResponseFieldsJSON = {\r\n  webauthn:\r\n    | {\r\n        type: 'create'\r\n        credential_options: { publicKey: ServerCredentialCreationOptions }\r\n      }\r\n    | {\r\n        type: 'request'\r\n        credential_options: { publicKey: ServerCredentialRequestOptions }\r\n      }\r\n}\r\n\r\n/**\r\n * JSON-serializable version of WebAuthn challenge response.\r\n * Used for server communication with base64url-encoded binary fields.\r\n */\r\nexport type AuthMFAChallengeWebauthnResponseDataJSON = Prettify<\r\n  AuthMFAChallengeResponseBase<'webauthn'> & AuthMFAChallengeWebauthnResponseFieldsJSON\r\n>\r\n\r\n/**\r\n * Server response type for WebAuthn MFA challenge.\r\n * Contains JSON-formatted WebAuthn options ready for browser API.\r\n */\r\nexport type AuthMFAChallengeWebauthnServerResponse =\r\n  RequestResult<AuthMFAChallengeWebauthnResponseDataJSON>\r\n\r\nexport type AuthMFAChallengeResponse =\r\n  | AuthMFAChallengeTOTPResponse\r\n  | AuthMFAChallengePhoneResponse\r\n  | AuthMFAChallengeWebauthnResponse\r\n\r\n/** response of ListFactors, which should contain all the types of factors that are available, this ensures we always include all */\r\nexport type AuthMFAListFactorsResponse<T extends typeof FactorTypes = typeof FactorTypes> =\r\n  RequestResult<\r\n    {\r\n      /** All available factors (verified and unverified). */\r\n      all: Prettify<Factor>[]\r\n\r\n      // Dynamically create a property for each factor type with only verified factors\r\n    } & {\r\n      [K in T[number]]: Prettify<Factor<K, 'verified'>>[]\r\n    }\r\n  >\r\n\r\nexport type AuthenticatorAssuranceLevels = 'aal1' | 'aal2'\r\n\r\nexport type AuthMFAGetAuthenticatorAssuranceLevelResponse = RequestResult<{\r\n  /** Current AAL level of the session. */\r\n  currentLevel: AuthenticatorAssuranceLevels | null\r\n\r\n  /**\r\n   * Next possible AAL level for the session. If the next level is higher\r\n   * than the current one, the user should go through MFA.\r\n   *\r\n   * @see {@link GoTrueMFAApi#challenge}\r\n   */\r\n  nextLevel: AuthenticatorAssuranceLevels | null\r\n\r\n  /**\r\n   * A list of all authentication methods attached to this session. Use\r\n   * the information here to detect the last time a user verified a\r\n   * factor, for example if implementing a step-up scenario.\r\n   */\r\n  currentAuthenticationMethods: AMREntry[]\r\n}>\r\n\r\n/**\r\n * Contains the full multi-factor authentication API.\r\n *\r\n */\r\nexport interface GoTrueMFAApi {\r\n  /**\r\n   * Starts the enrollment process for a new Multi-Factor Authentication (MFA)\r\n   * factor. This method creates a new `unverified` factor.\r\n   * To verify a factor, present the QR code or secret to the user and ask them to add it to their\r\n   * authenticator app.\r\n   * The user has to enter the code from their authenticator app to verify it.\r\n   *\r\n   * Upon verifying a factor, all other sessions are logged out and the current session's authenticator level is promoted to `aal2`.\r\n   */\r\n  enroll(params: MFAEnrollTOTPParams): Promise<AuthMFAEnrollTOTPResponse>\r\n  enroll(params: MFAEnrollPhoneParams): Promise<AuthMFAEnrollPhoneResponse>\r\n  enroll(params: MFAEnrollWebauthnParams): Promise<AuthMFAEnrollWebauthnResponse>\r\n  enroll(params: MFAEnrollParams): Promise<AuthMFAEnrollResponse>\r\n\r\n  /**\r\n   * Prepares a challenge used to verify that a user has access to a MFA\r\n   * factor.\r\n   */\r\n  challenge(params: MFAChallengeTOTPParams): Promise<Prettify<AuthMFAChallengeTOTPResponse>>\r\n  challenge(params: MFAChallengePhoneParams): Promise<Prettify<AuthMFAChallengePhoneResponse>>\r\n  challenge(params: MFAChallengeWebauthnParams): Promise<Prettify<AuthMFAChallengeWebauthnResponse>>\r\n  challenge(params: MFAChallengeParams): Promise<AuthMFAChallengeResponse>\r\n\r\n  /**\r\n   * Verifies a code against a challenge. The verification code is\r\n   * provided by the user by entering a code seen in their authenticator app.\r\n   */\r\n  verify(params: MFAVerifyTOTPParams): Promise<AuthMFAVerifyResponse>\r\n  verify(params: MFAVerifyPhoneParams): Promise<AuthMFAVerifyResponse>\r\n  verify(params: MFAVerifyWebauthnParams): Promise<AuthMFAVerifyResponse>\r\n  verify(params: MFAVerifyParams): Promise<AuthMFAVerifyResponse>\r\n\r\n  /**\r\n   * Unenroll removes a MFA factor.\r\n   * A user has to have an `aal2` authenticator level in order to unenroll a `verified` factor.\r\n   */\r\n  unenroll(params: MFAUnenrollParams): Promise<AuthMFAUnenrollResponse>\r\n\r\n  /**\r\n   * Helper method which creates a challenge and immediately uses the given code to verify against it thereafter. The verification code is\r\n   * provided by the user by entering a code seen in their authenticator app.\r\n   */\r\n  challengeAndVerify(params: MFAChallengeAndVerifyParams): Promise<AuthMFAVerifyResponse>\r\n\r\n  /**\r\n   * Returns the list of MFA factors enabled for this user.\r\n   *\r\n   * @see {@link GoTrueMFAApi#enroll}\r\n   * @see {@link GoTrueMFAApi#getAuthenticatorAssuranceLevel}\r\n   * @see {@link GoTrueClient#getUser}\r\n   *\r\n   */\r\n  listFactors(): Promise<AuthMFAListFactorsResponse>\r\n\r\n  /**\r\n   * Returns the Authenticator Assurance Level (AAL) for the active session.\r\n   *\r\n   * - `aal1` (or `null`) means that the user's identity has been verified only\r\n   * with a conventional login (email+password, OTP, magic link, social login,\r\n   * etc.).\r\n   * - `aal2` means that the user's identity has been verified both with a conventional login and at least one MFA factor.\r\n   *\r\n   * Although this method returns a promise, it's fairly quick (microseconds)\r\n   * and rarely uses the network. You can use this to check whether the current\r\n   * user needs to be shown a screen to verify their MFA factors.\r\n   *\r\n   */\r\n  getAuthenticatorAssuranceLevel(): Promise<AuthMFAGetAuthenticatorAssuranceLevelResponse>\r\n\r\n  // namespace for the webauthn methods\r\n  webauthn: WebAuthnApi\r\n}\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminDeleteFactorResponse = RequestResult<{\r\n  /** ID of the factor that was successfully deleted. */\r\n  id: string\r\n}>\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminDeleteFactorParams = {\r\n  /** ID of the MFA factor to delete. */\r\n  id: string\r\n\r\n  /** ID of the user whose factor is being deleted. */\r\n  userId: string\r\n}\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminListFactorsResponse = RequestResult<{\r\n  /** All factors attached to the user. */\r\n  factors: Factor[]\r\n}>\r\n\r\n/**\r\n * @expermental\r\n */\r\nexport type AuthMFAAdminListFactorsParams = {\r\n  /** ID of the user. */\r\n  userId: string\r\n}\r\n\r\n/**\r\n * Contains the full multi-factor authentication administration API.\r\n *\r\n * @expermental\r\n */\r\nexport interface GoTrueAdminMFAApi {\r\n  /**\r\n   * Lists all factors associated to a user.\r\n   *\r\n   */\r\n  listFactors(params: AuthMFAAdminListFactorsParams): Promise<AuthMFAAdminListFactorsResponse>\r\n\r\n  /**\r\n   * Deletes a factor on a user. This will log the user out of all active\r\n   * sessions if the deleted factor was verified.\r\n   *\r\n   * @see {@link GoTrueMFAApi#unenroll}\r\n   *\r\n   * @expermental\r\n   */\r\n  deleteFactor(params: AuthMFAAdminDeleteFactorParams): Promise<AuthMFAAdminDeleteFactorResponse>\r\n}\r\n\r\ntype AnyFunction = (...args: any[]) => any\r\ntype MaybePromisify<T> = T | Promise<T>\r\n\r\ntype PromisifyMethods<T> = {\r\n  [K in keyof T]: T[K] extends AnyFunction\r\n    ? (...args: Parameters<T[K]>) => MaybePromisify<ReturnType<T[K]>>\r\n    : T[K]\r\n}\r\n\r\nexport type SupportedStorage = PromisifyMethods<\r\n  Pick<Storage, 'getItem' | 'setItem' | 'removeItem'>\r\n> & {\r\n  /**\r\n   * If set to `true` signals to the library that the storage medium is used\r\n   * on a server and the values may not be authentic, such as reading from\r\n   * request cookies. Implementations should not set this to true if the client\r\n   * is used on a server that reads storage information from authenticated\r\n   * sources, such as a secure database or file.\r\n   */\r\n  isServer?: boolean\r\n}\r\n\r\nexport type InitializeResult = { error: AuthError | null }\r\n\r\nexport type CallRefreshTokenResult = RequestResult<Session>\r\n\r\nexport type Pagination = {\r\n  [key: string]: any\r\n  nextPage: number | null\r\n  lastPage: number\r\n  total: number\r\n}\r\n\r\nexport type PageParams = {\r\n  /** The page number */\r\n  page?: number\r\n  /** Number of items returned per page */\r\n  perPage?: number\r\n}\r\n\r\nexport type SignOut = {\r\n  /**\r\n   * Determines which sessions should be\r\n   * logged out. Global means all\r\n   * sessions by this account. Local\r\n   * means only this session. Others\r\n   * means all other sessions except the\r\n   * current one. When using others,\r\n   * there is no sign-out event fired on\r\n   * the current session!\r\n   */\r\n  scope?: 'global' | 'local' | 'others'\r\n}\r\n\r\ntype MFAEnrollParamsBase<T extends FactorType> = {\r\n  /** The type of factor being enrolled. */\r\n  factorType: T\r\n  /** Human readable name assigned to the factor. */\r\n  friendlyName?: string\r\n}\r\n\r\ntype MFAEnrollTOTPParamFields = {\r\n  /** Domain which the user is enrolled with. */\r\n  issuer?: string\r\n}\r\n\r\nexport type MFAEnrollTOTPParams = Prettify<MFAEnrollParamsBase<'totp'> & MFAEnrollTOTPParamFields>\r\n\r\ntype MFAEnrollPhoneParamFields = {\r\n  /** Phone number associated with a factor. Number should conform to E.164 format */\r\n  phone: string\r\n}\r\nexport type MFAEnrollPhoneParams = Prettify<\r\n  MFAEnrollParamsBase<'phone'> & MFAEnrollPhoneParamFields\r\n>\r\n\r\ntype MFAEnrollWebauthnFields = {\r\n  /** no extra fields for now, kept for consistency and for possible future changes  */\r\n}\r\n\r\n/**\r\n * Parameters for enrolling a WebAuthn factor.\r\n * Creates an unverified WebAuthn factor that must be verified with a credential.\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\r\n */\r\nexport type MFAEnrollWebauthnParams = Prettify<\r\n  MFAEnrollParamsBase<'webauthn'> & MFAEnrollWebauthnFields\r\n>\r\n\r\ntype AuthMFAEnrollResponseBase<T extends FactorType> = {\r\n  /** ID of the factor that was just enrolled (in an unverified state). */\r\n  id: string\r\n\r\n  /** Type of MFA factor.*/\r\n  type: T\r\n\r\n  /** Friendly name of the factor, useful for distinguishing between factors **/\r\n  friendly_name?: string\r\n}\r\n\r\ntype AuthMFAEnrollTOTPResponseFields = {\r\n  /** TOTP enrollment information. */\r\n  totp: {\r\n    /** Contains a QR code encoding the authenticator URI. You can\r\n     * convert it to a URL by prepending `data:image/svg+xml;utf-8,` to\r\n     * the value. Avoid logging this value to the console. */\r\n    qr_code: string\r\n\r\n    /** The TOTP secret (also encoded in the QR code). Show this secret\r\n     * in a password-style field to the user, in case they are unable to\r\n     * scan the QR code. Avoid logging this value to the console. */\r\n    secret: string\r\n\r\n    /** The authenticator URI encoded within the QR code, should you need\r\n     * to use it. Avoid loggin this value to the console. */\r\n    uri: string\r\n  }\r\n}\r\n\r\nexport type AuthMFAEnrollTOTPResponse = RequestResult<\r\n  Prettify<AuthMFAEnrollResponseBase<'totp'> & AuthMFAEnrollTOTPResponseFields>\r\n>\r\n\r\ntype AuthMFAEnrollPhoneResponseFields = {\r\n  /** Phone number of the MFA factor in E.164 format. Used to send messages  */\r\n  phone: string\r\n}\r\n\r\nexport type AuthMFAEnrollPhoneResponse = RequestResult<\r\n  Prettify<AuthMFAEnrollResponseBase<'phone'> & AuthMFAEnrollPhoneResponseFields>\r\n>\r\n\r\ntype AuthMFAEnrollWebauthnFields = {\r\n  /** no extra fields for now, kept for consistency and for possible future changes  */\r\n}\r\n\r\n/**\r\n * Response type for WebAuthn factor enrollment.\r\n * Returns the enrolled factor ID and metadata.\r\n * @see {@link https://w3c.github.io/webauthn/#sctn-registering-a-new-credential W3C WebAuthn Spec - Registering a New Credential}\r\n */\r\nexport type AuthMFAEnrollWebauthnResponse = RequestResult<\r\n  Prettify<AuthMFAEnrollResponseBase<'webauthn'> & AuthMFAEnrollWebauthnFields>\r\n>\r\n\r\nexport type JwtHeader = {\r\n  alg: 'RS256' | 'ES256' | 'HS256'\r\n  kid: string\r\n  typ: string\r\n}\r\n\r\nexport type RequiredClaims = {\r\n  iss: string\r\n  sub: string\r\n  aud: string | string[]\r\n  exp: number\r\n  iat: number\r\n  role: string\r\n  aal: AuthenticatorAssuranceLevels\r\n  session_id: string\r\n}\r\n\r\nexport type JwtPayload = RequiredClaims & {\r\n  [key: string]: any\r\n}\r\n\r\nexport interface JWK {\r\n  kty: 'RSA' | 'EC' | 'oct'\r\n  key_ops: string[]\r\n  alg?: string\r\n  kid?: string\r\n  [key: string]: any\r\n}\r\n\r\nexport const SIGN_OUT_SCOPES = ['global', 'local', 'others'] as const\r\nexport type SignOutScope = (typeof SIGN_OUT_SCOPES)[number]\r\n\r\n/**\r\n * OAuth client grant types supported by the OAuth 2.1 server.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClientGrantType = 'authorization_code' | 'refresh_token'\r\n\r\n/**\r\n * OAuth client response types supported by the OAuth 2.1 server.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClientResponseType = 'code'\r\n\r\n/**\r\n * OAuth client type indicating whether the client can keep credentials confidential.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClientType = 'public' | 'confidential'\r\n\r\n/**\r\n * OAuth client registration type.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClientRegistrationType = 'dynamic' | 'manual'\r\n\r\n/**\r\n * OAuth client object returned from the OAuth 2.1 server.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClient = {\r\n  /** Unique identifier for the OAuth client */\r\n  client_id: string\r\n  /** Human-readable name of the OAuth client */\r\n  client_name: string\r\n  /** Client secret (only returned on registration and regeneration) */\r\n  client_secret?: string\r\n  /** Type of OAuth client */\r\n  client_type: OAuthClientType\r\n  /** Token endpoint authentication method */\r\n  token_endpoint_auth_method: string\r\n  /** Registration type of the client */\r\n  registration_type: OAuthClientRegistrationType\r\n  /** URI of the OAuth client */\r\n  client_uri?: string\r\n  /** Array of allowed redirect URIs */\r\n  redirect_uris: string[]\r\n  /** Array of allowed grant types */\r\n  grant_types: OAuthClientGrantType[]\r\n  /** Array of allowed response types */\r\n  response_types: OAuthClientResponseType[]\r\n  /** Scope of the OAuth client */\r\n  scope?: string\r\n  /** Timestamp when the client was created */\r\n  created_at: string\r\n  /** Timestamp when the client was last updated */\r\n  updated_at: string\r\n}\r\n\r\n/**\r\n * Parameters for creating a new OAuth client.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type CreateOAuthClientParams = {\r\n  /** Human-readable name of the OAuth client */\r\n  client_name: string\r\n  /** URI of the OAuth client */\r\n  client_uri?: string\r\n  /** Array of allowed redirect URIs */\r\n  redirect_uris: string[]\r\n  /** Array of allowed grant types (optional, defaults to authorization_code and refresh_token) */\r\n  grant_types?: OAuthClientGrantType[]\r\n  /** Array of allowed response types (optional, defaults to code) */\r\n  response_types?: OAuthClientResponseType[]\r\n  /** Scope of the OAuth client */\r\n  scope?: string\r\n}\r\n\r\n/**\r\n * Response type for OAuth client operations.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClientResponse = RequestResult<OAuthClient>\r\n\r\n/**\r\n * Response type for listing OAuth clients.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport type OAuthClientListResponse =\r\n  | {\r\n      data: { clients: OAuthClient[]; aud: string } & Pagination\r\n      error: null\r\n    }\r\n  | {\r\n      data: { clients: [] }\r\n      error: AuthError\r\n    }\r\n\r\n/**\r\n * Contains all OAuth client administration methods.\r\n * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n */\r\nexport interface GoTrueAdminOAuthApi {\r\n  /**\r\n   * Lists all OAuth clients with optional pagination.\r\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  listClients(params?: PageParams): Promise<OAuthClientListResponse>\r\n\r\n  /**\r\n   * Creates a new OAuth client.\r\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  createClient(params: CreateOAuthClientParams): Promise<OAuthClientResponse>\r\n\r\n  /**\r\n   * Gets details of a specific OAuth client.\r\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  getClient(clientId: string): Promise<OAuthClientResponse>\r\n\r\n  /**\r\n   * Deletes an OAuth client.\r\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  deleteClient(clientId: string): Promise<OAuthClientResponse>\r\n\r\n  /**\r\n   * Regenerates the secret for an OAuth client.\r\n   * Only relevant when the OAuth 2.1 server is enabled in Supabase Auth.\r\n   *\r\n   * This function should only be called on a server. Never expose your `service_role` key in the browser.\r\n   */\r\n  regenerateClientSecret(clientId: string): Promise<OAuthClientResponse>\r\n}\r\n"],"mappings":"AA+GA,MAAMA,mBAAmB,GAAG,CAAC,QAAQ,EAAE,YAAY,EAAE,OAAO,CAAU;AA+ItE,MAAMC,UAAU,GAAG,CACjB,UAAU,EACV,KAAK,EACL,OAAO,EACP,MAAM,EACN,UAAU,EACV,WAAW,EACX,cAAc,EACd,WAAW,EACX,UAAU,EACV,WAAW,EACX,MAAM,CACE;AAoCV,MAAMC,WAAW,GAAG,CAAC,MAAM,EAAE,OAAO,EAAE,UAAU,CAAU;AAO1D,MAAMC,0BAA0B,GAAG,CAAC,UAAU,EAAE,YAAY,CAAU;AAsnBtE,MAAMC,eAAe,GAAG,CAAC,KAAK,EAAE,UAAU,CAAU;AA6fpD,OAAO,MAAMC,eAAe,GAAG,CAAC,QAAQ,EAAE,OAAO,EAAE,QAAQ,CAAU","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}